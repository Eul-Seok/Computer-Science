# 렌더링 파이프라인의 이해

3D 그래픽스에서 객체가 화면에 그려지기까지의 과정은 **렌더링 파이프라인(Rendering Pipeline)**을 통해 이루어집니다. 이 파이프라인은 3D 모델 데이터(**정점**, **텍스처** 등)가 최종적으로 화면의 2D 픽셀로 변환되는 일련의 단계이며, **GPU**가 매 **프레임**마다 실시간으로 반복 수행합니다.
> - **GPU(Graphics Processing Unit)**: 그래픽 연산에 특화된 프로세서. 수많은 코어를 활용한 병렬 처리에 강점을 가져, 렌더링 파이프라인의 대부분 단계를 담당합니다.
> - **정점(Vertex)**: 3D 모델을 구성하는 가장 기본적인 요소로, 위치(x,y,z) 정보를 가집니다. 이 정점들을 연결하여 삼각형(폴리곤)을 만듭니다.
> - **텍스처(Texture)**: 모델의 표면에 입히는 2D 이미지. 벽돌, 나무, 피부 등 재질을 표현하는 데 사용됩니다.
> - **프레임(Frame)**: 화면에 그려지는 한 장의 정지 이미지. 실시간 렌더링에서는 초당 수십 장의 프레임(FPS)을 그려 움직이는 것처럼 보이게 합니다.

## 1. 렌더링 파이프라인의 전체 흐름

전체 과정은 크게 **좌표 변환** 단계, **래스터라이제이션** 단계, **픽셀 처리** 단계로 나눌 수 있습니다.

**Local Space → World Space → View Space → Clip Space → NDC → Screen Space**

1.  **로컬 좌표계 (Local Space)**: 각 객체가 자신의 원점을 기준으로 모델링된 고유의 좌표 공간입니다.
2.  **월드 좌표계 (World Space)**: 게임 세계의 공통된 원점을 기준으로 모든 객체가 배치된 가상 공간입니다.
3.  **뷰(카메라) 좌표계 (View/Camera Space)**: 카메라의 시점에서 세상을 바라보도록 재배치된 공간입니다.
4.  **클립 공간 (Clip Space)**: 카메라의 시야(**Frustum**) 내에 들어오는 부분만 남기고 잘라내기(**Clipping**) 위한 4D **동차 좌표** 공간입니다.
> - **프러스텀(Frustum)**: '절두체'라고도 하며, 카메라의 시야를 나타내는 잘린 피라미드 형태의 3D 공간. 이 공간 안에 있는 것만 화면에 보이게 됩니다.
> - **클리핑(Clipping)**: 프러스텀 밖에 있는, 즉 화면에 보이지 않는 부분을 잘라내어 렌더링 대상에서 제외하는 과정.
> - **동차 좌표(Homogeneous Coordinates)**: 3D 좌표(x,y,z)에 w라는 추가 차원을 더한 4D 좌표. 원근 투영 변환과 같은 복잡한 행렬 계산을 용이하게 합니다.
5.  **NDC (Normalized Device Coordinates)**: 클립 공간의 좌표를 `-1`에서 `1` 사이의 정규화된 값으로 변환한 공간입니다.
6.  **스크린 좌표계 (Screen Space)**: NDC 좌표를 실제 화면 해상도에 맞는 픽셀 위치로 변환한 2D 공간입니다.

이후 래스터라이제이션과 픽셀 처리를 거쳐 최종 이미지가 **프레임 버퍼**에 그려집니다.
> - **프레임 버퍼(Frame Buffer)**: 렌더링된 최종 픽셀 색상 정보가 저장되는 메모리 공간. 이 버퍼의 내용이 화면에 표시됩니다.

## 2. 핵심 좌표 변환 (행렬 변환)

좌표 변환은 수학적으로는 행렬 곱셈의 연속이며, 시각적으로는 객체가 "어디에 있고", "어떻게 보이며", "어디에 그려질지"를 결정합니다.

-   **모델 행렬 (Model Matrix)**: 로컬 좌표 → 월드 좌표
    -   객체를 게임 세계 내 특정 위치에 배치(Translation), 회전(Rotation), 크기 조절(Scale)하는 변환입니다. 객체의 "존재"를 결정합니다.

-   **뷰 행렬 (View Matrix)**: 월드 좌표 → 뷰 좌표
    -   게임 세계 전체를 카메라 시점에서 바라보도록 재배치합니다. 실제로는 카메라를 움직이는 대신, 세상을 반대로 움직여 카메라가 원점에 있는 것처럼 만듭니다. "시점"을 결정합니다.

-   **프로젝션 행렬 (Projection Matrix)**: 뷰 좌표 → 클립 공간
    -   3D 공간을 2D 화면에 투영하기 위한 변환입니다. **원근 투영(Perspective)**을 통해 가까운 것은 크게, 먼 것은 작게 보이도록 왜곡하여 현실감을 부여합니다. **시야각(FOV)**, **종횡비(Aspect Ratio)** 등을 설정합니다.
    > - **시야각(FOV, Field of View)**: 카메라가 한 번에 볼 수 있는 각도의 범위. 넓을수록 왜곡이 심해지고, 좁을수록 확대되어 보입니다.
    > - **종횡비(Aspect Ratio)**: 렌더링될 화면의 너비와 높이의 비율 (예: 16:9).

-   **뷰포트 변환 (Viewport Transform)**: NDC → 스크린 좌표
    -   `-1` ~ `1` 범위의 NDC 좌표를 실제 화면 해상도(예: 1920x1080)에 맞는 픽셀 위치로 매핑합니다. "화면상의 위치"를 최종 결정합니다.

## 3. 래스터라이제이션 (Rasterization)

래스터라이제이션은 정점(Vertex)으로 구성된 3D 삼각형을 2D 화면에 그릴 수 있도록 **픽셀 단위로 변환**하는 핵심 과정입니다. 이 단계 전후로 다양한 최적화가 이루어집니다.

1.  **정점 셰이더 (Vertex Shader)**: 각 정점의 위치를 모델 공간에서 클립 공간으로 변환합니다.
2.  **프리미티브 조립 (Primitive Assembly)**: 변환된 정점들을 삼각형, 선, 점 등의 기본 도형(**프리미티브**)으로 조합합니다.
> - **프리미티브(Primitive)**: GPU가 그릴 수 있는 가장 기본적인 도형 단위. 보통 삼각형이 사용됩니다.
3.  **백페이스 컬링 (Back-face Culling)**: 카메라를 등지고 있어 보이지 않는 삼각형의 뒷면을 렌더링 대상에서 제외하여 처리량을 줄이는 기본 최적화 기법입니다.
4.  **래스터화 (Rasterization)**: 이 삼각형이 화면의 어떤 픽셀들을 덮고 있는지 판단하여 픽셀 조각(**프래그먼트**)으로 분해합니다.
> - **프래그먼트(Fragment)**: 픽셀이 되기 전의 후보. 색상, 깊이, 텍스처 좌표 등 최종 픽셀이 되기 위해 필요한 모든 데이터를 가지고 있습니다.
5.  **프래그먼트 셰이더 (Fragment Shader)**: 각 프래그먼트(픽셀 후보)에 대해 텍스처, 조명 등을 계산하여 최종 색상을 결정합니다.

## 4. 셰이더 (Shader)의 역할

셰이더는 그래픽 파이프라인의 각 단계에서 개발자가 직접 프로그래밍할 수 있는 GPU 실행 코드입니다. 이를 통해 렌더링 과정을 제어하고 다채로운 시각 효과를 만듭니다.

-   **정점 셰이더 (Vertex Shader)**: 정점 단위로 실행되며, 주로 정점의 위치 변환과 관련된 계산을 담당합니다.
-   **프래그먼트 셰이더 (Fragment/Pixel Shader)**: 픽셀 단위로 실행되며, 픽셀의 최종 색상을 결정하는 모든 계산(텍스처 매핑, 조명, 그림자 등)을 담당합니다.

### GPU의 병렬 처리와 셰이더
GPU의 가장 큰 강점은 수천, 수만 개의 코어를 활용한 **대규모 병렬 처리** 능력에 있습니다. 셰이더는 이러한 구조에 최적화되어 있습니다.
-   **정점 셰이더**는 모델을 구성하는 **모든 정점에 대해 독립적으로, 그리고 동시에** 실행됩니다. 10,000개의 정점을 가진 모델이 있다면, GPU는 이론적으로 10,000개의 스레드를 동시에 실행하여 각 정점의 위치를 계산합니다.
-   **프래그먼트 셰이더** 역시 래스터라이즈된 **모든 픽셀 조각에 대해 독립적으로, 그리고 동시에** 실행됩니다. 이를 통해 수백만 개의 픽셀 색상을 병렬로 빠르게 계산할 수 있습니다.

### 게임 엔진과 머티리얼 시스템
실무에서는 개발자나 아티스트가 매번 셰이더 코드를 직접 작성하는 복잡함을 줄이기 위해, 게임 엔진(Unity, Unreal 등)은 **머티리얼(Material)** 시스템을 제공합니다. 머티리얼은 특정 셰이더와 그 셰이더에 필요한 텍스처, 색상, 속성(거칠기, 금속성 등)을 묶어놓은 **에셋**입니다.
> - **머티리얼(Material)**: 오브젝트의 표면이 어떻게 보일지를 정의하는 데이터 묶음. 어떤 셰이더를 사용하고, 그 셰이더에 어떤 값(색상, 텍스처 등)을 전달할지를 결정합니다.
> - **에셋(Asset)**: 게임을 구성하는 모든 종류의 데이터 파일. 3D 모델, 텍스처, 사운드, 머티리얼, 코드 스크립트 등이 모두 에셋에 해당합니다.

## 5. 깊이 판정과 Z-버퍼 (Z-buffering)

Z-버퍼는 3D 공간에서 객체 간의 가려짐(Occlusion)을 올바르게 처리하기 위한 기법입니다.

-   **동작 원리**: 화면 해상도와 동일한 크기의 별도 버퍼(Z-buffer)에 각 픽셀의 깊이 값(카메라로부터의 거리)을 저장합니다. 새로운 픽셀을 그릴 때, 버퍼에 저장된 깊이 값과 새로 그릴 픽셀의 깊이 값을 비교합니다.
-   **판정**: 새로 그릴 픽셀이 기존 픽셀보다 카메라에 더 가깝다면, 해당 픽셀을 덮어쓰고 Z-버퍼의 깊이 값도 갱신합니다. 더 멀다면, 해당 픽셀을 버립니다.
-   이를 통해 물체가 서로 겹쳐 있을 때, 더 가까운 물체만 보이도록 정확하게 처리할 수 있습니다.

## 6. 최종 출력 및 후처리 (Output Merger & Post-processing)
프래그먼트 셰이더를 거친 픽셀들은 최종적으로 화면에 그려지기 전에 몇 가지 단계를 더 거칩니다.

-   **블렌딩 (Blending)**: 반투명 오브젝트(유리, 물, UI 등)를 렌더링할 때, 새로 그려질 픽셀의 색상과 프레임 버퍼에 이미 그려져 있는 픽셀의 색상을 정해진 공식에 따라 혼합하는 과정입니다.
-   **후처리 (Post-processing)**: 씬 전체가 렌더링된 최종 이미지에 추가적인 시각 효과를 적용하는 단계입니다.
    -   **블룸 (Bloom)**: 밝은 영역이 주변으로 빛나는 것처럼 보이게 하는 효과.
    -   **모션 블러 (Motion Blur)**: 빠르게 움직이는 오브젝트에 잔상을 남겨 운동감을 강조하는 효과.
    -   **안티에일리어싱 (Anti-Aliasing)**: **계단 현상(Aliasing)**을 완화하여 경계선을 부드럽게 만드는 기법 (예: FXAA, TAA).
    > - **계단 현상(Aliasing)**: 픽셀 기반의 화면에서 선이나 경계면이 톱니 모양처럼 거칠게 보이는 현상.

## 7. 주요 렌더링 최적화 기법
렌더링 파이프라인의 각 단계에서는 불필요한 계산을 줄이기 위한 다양한 최적화 기법이 적용됩니다.

-   **컬링 (Culling)**: 화면에 보이지 않을 오브젝트를 미리 렌더링 대상에서 제외하는 기술입니다.
    -   **프러스텀 컬링 (Frustum Culling)**: 카메라의 시야각(절두체) 밖에 있는 오브젝트를 렌더링하지 않습니다. 가장 기본적인 컬링 기법입니다.
    -   **백페이스 컬링 (Back-face Culling)**: 카메라를 등지고 있어 보이지 않는 폴리곤의 뒷면을 그리지 않습니다. 대부분의 오브젝트 뒷면은 보이지 않으므로 효과가 매우 큽니다.
    -   **오클루전 컬링 (Occlusion Culling)**: 다른 오브젝트에 완전히 가려져서 보이지 않는 오브젝트를 렌더링하지 않습니다. 계산 비용이 비싸지만, 복잡한 씬에서 효과적입니다.

-   **LOD (Level of Detail)**: 카메라와의 거리에 따라 폴리곤 수가 다른 모델로 교체하여 GPU의 정점 처리 부하를 줄입니다. (자세한 내용은 '렌더링 최적화 기법' 문서 참고)