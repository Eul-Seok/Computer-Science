# 렌더링 최적화 기법

실시간 렌더링 환경, 특히 게임에서는 매 프레임을 정해진 시간(예: 60FPS 기준 16.6ms) 안에 그려내야 합니다. 제한된 시간 안에 높은 품질의 그래픽을 구현하기 위해서는 렌더링 파이프라인의 각 단계에서 발생하는 병목을 찾아 해결하는 **최적화** 과정이 필수적입니다. 여기서는 대표적인 렌더링 최적화 기법들을 다룹니다.

## 1. 드로우 콜 최적화 (Draw Call Optimization)

<b>드로우 콜(Draw Call)</b>은 CPU가 GPU에게 "이 오브젝트를 그려라"라고 보내는 렌더링 명령입니다. 이 명령이 많아질수록 CPU와 GPU 간의 통신 오버헤드가 증가하여 **CPU 병목**의 주된 원인이 됩니다. GPU가 아무리 빨라도 CPU가 명령을 제때 주지 못하면 전체 프레임 속도가 저하됩니다.
> - **CPU 병목**: CPU가 GPU에게 렌더링 명령을 충분히 빠르게 전달하지 못하거나, 다른 작업을 처리하느라 지연되어 GPU가 유휴 상태가 되는 현상.

-   **배칭 (Batching)**: 동일한 머티리얼을 사용하는 여러 오브젝트를 하나의 드로우 콜로 묶어 처리하는 기법입니다. (예: 여러 개의 돌멩이 오브젝트를 하나로 묶어 렌더링)
-   **인스턴싱 (Instancing)**: 동일한 메시를 여러 위치에 반복해서 렌더링할 때, 하나의 드로우 콜로 여러 인스턴스를 한 번에 처리하는 기법입니다.
    -   **하드웨어 인스턴싱 (Hardware Instancing)**: GPU가 인스턴싱을 직접 처리하여 CPU 부하를 더욱 줄입니다.
    -   **인디렉트 드로우 (Indirect Draw)**: GPU가 드로우 콜 자체를 생성하고 실행하여, CPU가 GPU에게 드로우 콜을 보내는 오버헤드까지 제거하는 최신 기법입니다.

## 2. 오버드로우 최적화 (Overdraw Optimization)

<b>오버드로우(Overdraw)</b>는 화면의 같은 픽셀이 여러 번 그려지는 현상입니다. 반투명 UI, 파티클 효과 등 여러 그래픽 요소가 겹쳐 있을 때 발생하며, 픽셀 셰이더 연산을 불필요하게 반복하여 **GPU 병목**을 유발합니다.
> - **GPU 병목**: GPU가 픽셀 셰이더 연산, 메모리 접근 등으로 인해 처리 속도가 지연되어 CPU가 다음 명령을 기다리게 되는 현상.

-   **Z-Prepass (Depth Pre-pass)**: 본 렌더링에 앞서, 씬의 깊이 정보만 먼저 Z-버퍼에 기록하는 단계입니다. 이후 본 렌더링에서는 Z-테스트를 통과하는 픽셀에 대해서만 복잡한 픽셀 셰이더를 실행하여 오버드로우를 줄입니다.
-   **컬링 (Culling)**: 화면에 보이지 않는 오브젝트를 렌더링 대상에서 제외하는 기법입니다.
    -   **프러스텀 컬링 (Frustum Culling)**: 카메라의 시야각(Frustum) 밖에 있는 오브젝트를 렌더링하지 않습니다.
    -   **오클루전 컬링 (Occlusion Culling)**: 다른 오브젝트에 완전히 가려져 보이지 않는 오브젝트를 렌더링하지 않습니다.

## 3. LOD (Level of Detail)

**LOD**는 카메라와의 거리에 따라 오브젝트를 각기 다른 복잡도의 모델로 교체하여 렌더링하는 기법입니다. 렌더링 부하와 시각적 품질 사이의 균형을 맞추는 핵심적인 최적화 전략입니다.

-   **원리**: 가까이 있는 오브젝트는 폴리곤 수가 많은 고품질 모델(LOD 0)을, 멀리 있는 오브젝트는 폴리곤 수가 적은 저품질 모델(LOD 1, LOD 2...)을 사용합니다. 이를 통해 GPU가 처리해야 할 정점(Vertex)의 수를 크게 줄일 수 있습니다.
-   **HLOD (Hierarchical LOD)**: 일반 LOD를 확장한 개념으로, 여러 개의 오브젝트를 하나의 그룹으로 묶어 계층적으로 LOD를 적용합니다. 예를 들어, 멀리 있는 마을의 건물들을 하나의 단순화된 모델로 합쳐서 렌더링하여 드로우 콜과 정점 수를 동시에 줄입니다. 특히 오픈월드 게임에서 원경(Distant View)을 효율적으로 처리하는 데 필수적입니다.

## 4. 텍스처 최적화 (Texture Optimization)

텍스처는 GPU 메모리와 대역폭을 많이 사용하는 요소이므로, 효율적인 관리가 중요합니다.

-   **밉맵 (Mipmap)**: 오브젝트가 카메라로부터 멀어질수록 더 낮은 해상도의 텍스처를 자동으로 사용하도록 미리 여러 단계의 해상도 텍스처를 생성해두는 기법입니다. GPU 메모리 접근 비용을 줄이고 텍스처 캐시 효율을 높여 성능을 향상시킵니다.
-   **텍스처 아틀라스 (Texture Atlas)**: 여러 개의 작은 텍스처들을 하나의 큰 텍스처에 모아두는 기법입니다. 이를 통해 드로우 콜 수를 줄이고, 텍스처 스와핑(swapping)으로 인한 상태 전환 비용을 감소시킵니다.

## 5. 셰이더 최적화 (Shader Optimization)

셰이더는 GPU에서 픽셀 단위로 실행되는 코드이므로, 비효율적인 셰이더는 GPU 병목의 주된 원인이 됩니다.

-   **불필요한 분기(Branch) 최소화**: GPU는 **SIMD(Single Instruction, Multiple Data)** 방식으로 동작하므로, `if/else`와 같은 조건문은 모든 스레드가 분기 경로를 따라가야 할 수 있어 성능 저하를 유발합니다.
> - **SIMD (Single Instruction, Multiple Data)**: 하나의 명령어로 여러 데이터를 동시에 처리하는 병렬 처리 방식. GPU의 핵심 아키텍처입니다.
-   **공통 연산 캐싱 및 재사용**: 여러 번 사용되는 계산 결과는 변수에 저장하여 재사용하고, 불필요한 연산을 제거합니다.
-   **정점 셰이더에서 가능한 계산 미리 처리**: 픽셀 셰이더는 화면의 모든 픽셀에 대해 실행되므로, 픽셀 셰이더에서 수행되는 연산은 정점 셰이더로 옮겨 미리 처리할 수 있다면 성능에 큰 이득이 됩니다.
-   **모바일 환경에서의 픽셀 셰이더 최적화**: 모바일 GPU는 데스크톱 GPU보다 픽셀 셰이더 연산 능력에 제약이 크므로, 픽셀 셰이더의 복잡도를 최소화하는 것이 특히 중요합니다.

## 6. GPU 파이프라인 최적화 (GPU Pipeline Optimization)

GPU 자체의 렌더링 파이프라인을 효율적으로 활용하는 기법입니다.

-   **GPU Early-Z / Hierarchical-Z**: 픽셀 셰이더를 실행하기 전에 깊이 테스트(Z-Test)를 먼저 수행하여, 다른 오브젝트에 의해 가려질 픽셀은 아예 픽셀 셰이더 연산을 건너뛰도록 하는 기법입니다. 이를 통해 불필요한 픽셀 셰이더 연산을 줄여 GPU 부하를 크게 감소시킵니다.

## 7. CPU/GPU 병렬 처리 (Multithreading & Async Compute)

현대 게임 엔진은 CPU와 GPU의 자원을 최대한 활용하기 위해 병렬 처리 기법을 적극적으로 사용합니다.

-   **CPU 멀티스레딩**: 렌더링 파이프라인의 CPU 측 작업(씬 그래프 순회, 드로우 콜 준비, 컬링 등)을 여러 CPU 코어에 분산하여 처리합니다. 이를 통해 CPU 병목을 완화하고 GPU가 더 많은 작업을 할 수 있도록 합니다.
-   **GPU 비동기 컴퓨트 (Async Compute)**: GPU가 그래픽 렌더링 작업과 컴퓨트 셰이더(물리, AI, 포스트 프로세싱 등) 작업을 동시에 병렬로 실행할 수 있도록 하는 기술입니다. GPU의 유휴 시간을 줄여 전체적인 프레임 타임을 단축시킵니다.

## 8. 리소스 관리 최적화 (Resource Management Optimization)

대규모 씬이나 오픈월드 게임에서는 메모리 사용량과 I/O 병목을 줄이기 위한 리소스 관리 전략이 중요합니다.

-   **리소스 스트리밍 (Resource Streaming)**: 게임 진행에 따라 필요한 텍스처, 모델, 사운드 등의 리소스만 메모리에 로드하고, 더 이상 필요 없는 리소스는 언로드하여 메모리 사용량을 최적화하고 로딩 시간을 줄이는 기법입니다.

### 리소스 압축 기법
메모리 사용량과 디스크 I/O를 줄이기 위해 리소스를 압축하는 기법도 중요합니다.

-   **텍스처 압축 (Texture Compression)**: 텍스처 데이터를 압축하여 GPU 메모리 사용량과 대역폭을 줄입니다. (예: **BCn 포맷**, **ASTC 포맷**)
> - **BCn (Block Compression)**: DirectX에서 주로 사용되는 텍스처 압축 포맷.
> - **ASTC (Adaptive Scalable Texture Compression)**: 모바일 GPU에서 널리 사용되는 유연한 텍스처 압축 포맷.
-   **메시 압축 (Mesh Compression)**: 3D 모델의 정점 데이터를 압축하여 파일 크기를 줄이고 로딩 시간을 단축합니다. (예: **Draco**)
> - **Draco**: Google에서 개발한 3D 메시 및 포인트 클라우드 압축 라이브러리.

## 9. 렌더링 파이프라인 선택 전략 (Rendering Pipeline Selection Strategy)

게임의 특성과 목표 플랫폼에 따라 적절한 렌더링 파이프라인을 선택하는 것도 중요한 최적화 전략입니다.

-   **포워드 렌더링 (Forward Rendering)**:
    -   **장점**: 구조가 단순하고 구현이 쉬우며, 반투명 객체 처리나 **MSAA(Multi-Sample Anti-Aliasing)** 적용이 용이합니다.
    > - **MSAA (Multi-Sample Anti-Aliasing)**: 픽셀의 경계면에서 여러 샘플을 취해 색상을 평균화하여 계단 현상을 줄이는 안티앨리어싱 기법.
    -   **단점**: 광원의 수가 늘어날수록 오브젝트별 조명 계산이 기하급수적으로 증가하여 성능이 급격히 저하됩니다. (오브젝트 수 x 광원 수)
-   **디퍼드 렌더링 (Deferred Rendering)**:
    -   **장점**: 광원의 수에 거의 영향을 받지 않아 수백, 수천 개의 동적 광원을 효율적으로 처리할 수 있습니다.
    -   **단점**: **G-buffer**를 위한 추가적인 메모리와 대역폭이 필요하며, 반투명 객체 처리와 MSAA 적용이 까다롭습니다.
    > - **G-buffer (Geometry Buffer)**: 디퍼드 렌더링에서 씬의 기하학적 정보(위치, 법선, 색상 등)를 저장하는 여러 장의 텍스처 버퍼.

### 최신 하이브리드 렌더링 파이프라인
최근에는 포워드와 디퍼드 렌더링의 장점을 결합한 하이브리드 파이프라인이 많이 사용됩니다.

-   **포워드+ 렌더링 (Forward+ Rendering)**: 포워드 렌더링 기반이지만, 타일(Tile) 또는 클러스터(Cluster) 기반의 광원 컬링(Light Culling)을 통해 광원 수가 많아도 효율적으로 처리할 수 있도록 개선된 방식입니다.
-   **클러스터드 렌더링 (Clustered Rendering)**: 뷰 프러스텀을 3D 그리드(클러스터)로 나누고, 각 클러스터에 영향을 미치는 광원 목록을 미리 계산하여 픽셀 셰이더에서 필요한 광원만 처리하도록 합니다.

## 10. 플랫폼별 최적화 고려사항 (Platform-specific Optimization Considerations)

최적화 전략은 게임이 실행될 플랫폼의 하드웨어 특성에 맞춰 달라져야 합니다.

-   **PC / 콘솔 환경**:
    -   상대적으로 CPU와 GPU 파워가 충분하므로, 드로우 콜 최적화(CPU 병목 완화)와 멀티스레딩 활용이 중요합니다.
    -   고품질 셰이더와 텍스처를 사용하되, GPU의 연산 부하를 효율적으로 분산하는 데 집중합니다.
    -   **레이 트레이싱 (Ray Tracing)**: 최신 콘솔(PS5, Xbox Series X) 및 PC GPU는 레이 트레이싱 전용 하드웨어를 갖추고 있습니다. 이를 활용한 실시간 레이 트레이싱은 그림자, 반사, 전역 조명 등 사실적인 광원 효과를 구현하지만, 여전히 높은 연산 비용을 요구하므로 신중한 최적화가 필요합니다.
        -   **하이브리드 렌더링 (Hybrid Rendering)**: 레이 트레이싱의 높은 연산 비용을 줄이기 위해, 래스터라이제이션으로 대부분의 씬을 렌더링하고, 반사나 그림자 등 특정 효과에만 레이 트레이싱을 부분적으로 적용하는 전략입니다.
-   **모바일 환경**:
    -   CPU와 GPU 자원이 제한적이고, 배터리 소모 및 발열 문제가 중요합니다.
    -   **타일 기반 지연 렌더링 (Tile-based Deferred Rendering, TBDR)**: 많은 모바일 GPU가 TBDR 아키텍처를 사용합니다. 이는 화면을 작은 타일로 나누어 렌더링함으로써 메모리 대역폭 사용량을 줄이고 전력 효율을 높입니다. TBDR 환경에서는 오버드로우를 최소화하는 것이 특히 중요합니다.
        -   **UI 최적화**: 모바일에서는 오버드로우가 특히 성능에 큰 영향을 미치므로, UI 요소의 알파 블렌딩을 최소화하고, 파티클 효과를 단순화하는 등 픽셀 연산을 줄이는 노력이 중요합니다.
    -   **텍스처/셰이더 최적화**: 텍스처 해상도를 낮추고, 셰이더의 복잡도를 최소화합니다.
    -   **오버드로우 최소화**: 모바일 GPU는 <b>필 레이트(Fill Rate)</b>에 민감하므로, 오버드로우를 최대한 줄이는 것이 핵심입니다.
    > - **필 레이트(Fill Rate)**: GPU가 초당 화면에 그릴 수 있는 픽셀의 수. 모바일 GPU는 데스크톱 GPU보다 필 레이트가 낮아 오버드로우에 더 취약합니다.
    -   **메모리 사용량 관리**: 리소스 스트리밍 등을 통해 메모리 사용량을 엄격하게 관리합니다.