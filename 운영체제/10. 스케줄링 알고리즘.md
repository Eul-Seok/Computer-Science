# CPU 스케줄링 알고리즘

## 1. CPU 스케줄링이란?

CPU 스케줄링은 운영체제가 여러 프로세스 중 어떤 프로세스에게 CPU를 할당할지 결정하는 규칙입니다. 이 규칙에 따라 시스템의 처리율, 응답 시간, 공정성 등이 크게 달라지므로, 시스템의 목적에 맞는 적절한 알고리즘을 선택하는 것이 중요합니다.

> **- 스케줄링의 목표:** CPU 이용률 극대화, 처리량(throughput) 극대화, 응답 시간(response time) 최소화, 대기 시간(waiting time) 최소화, 공정성 확보 등 다양한 목표가 있습니다.

## 2. 주요 알고리즘 종류와 특징

### 가. FCFS (First-Come, First-Served)

**먼저 온 순서대로 처리 (선입선출)** 하는 가장 간단한 비선점 스케줄링 방식입니다.

- **장점:**
  - 구현이 매우 간단하고 직관적입니다.
- **단점:**
  - 처리 시간이 긴 프로세스가 먼저 도착하면 뒤따르는 짧은 프로세스들의 대기 시간이 길어지는 **호송 효과(Convoy Effect)** 가 발생할 수 있습니다.
    > **- 호송 효과란?** 마치 고속도로 1차선에서 느린 트럭 한 대가 모든 차들을 막고 있는 것처럼, 긴 작업 하나가 전체 시스템의 평균 응답 시간을 저하시키는 현상을 말합니다.

### 나. SJF (Shortest-Job-First)

**실행 시간이 가장 짧은 프로세스를 먼저 처리**하는 방식으로, 평균 대기 시간을 최소화하는 데 효과적입니다. 이 알고리즘은 비선점 방식과 선점 방식으로 나뉩니다.

- **비선점 SJF:** 일단 한 번 CPU를 할당받으면, 해당 프로세스가 끝날 때까지 실행됩니다.
- **선점 SJF (SRTF: Shortest Remaining Time First):** 현재 실행 중인 프로세스의 남은 시간보다 더 짧은 실행 시간을 가진 새로운 프로세스가 도착하면, CPU를 빼앗아 새로운 프로세스에게 할당합니다.

- **장점:**
  - 시스템의 평균 대기 시간을 최소화하여 처리율을 높일 수 있습니다. (특히 SRTF가 더 효과적입니다.)
- **단점:**
  - 프로세스의 실제 실행 시간을 미리 정확히 예측하기 어렵습니다.
  - 실행 시간이 긴 프로세스는 계속해서 새로운 짧은 프로세스들에게 밀려 무한정 기다리게 될 수 있는 **기아 현상(Starvation)** 이 발생할 수 있습니다.

### 다. 우선순위 스케줄링 (Priority Scheduling)

각 프로세스에 우선순위를 부여하여, 가장 높은 우선순위를 가진 프로세스에게 CPU를 할당하는 방식입니다.

- **종류:**
  - **정적 우선순위(Static Priority):** 프로세스 생성 시 부여된 우선순위가 해당 프로세스가 종료될 때까지 바뀌지 않습니다.
  - **동적 우선순위(Dynamic Priority):** 프로세스의 상태(예: 대기 시간)에 따라 우선순위가 동적으로 변경됩니다.
- **장점:**
  - 시스템의 중요한 작업을 먼저 처리하도록 보장할 수 있습니다.
- **단점:**
  - 우선순위가 낮은 프로세스가 무한정 기다리게 되는 <b>기아 현상(Starvation)</b>이 발생할 수 있습니다. (이를 해결하기 위해 오래 기다린 프로세스의 우선순위를 높여주는 'Aging' 기법을 사용하기도 합니다.)

### 라. 라운드 로빈 (Round Robin, RR)

모든 프로세스에게 <b>동일한 시간 할당량(Time Quantum)</b>을 부여하고, 그 시간 안에 작업을 마치지 못하면 준비 큐(Ready Queue)의 맨 뒤로 보내는 선점 스케줄링 방식입니다.

- **장점:**
  - 모든 프로세스가 공평하게 CPU 시간을 할당받아 응답 시간이 짧고 예측 가능합니다. 대화형(Interactive) 시스템에 적합합니다.
- **단점:**
  - 시간 할당량이 너무 짧으면 잦은 컨텍스트 스위칭으로 인한 오버헤드가 커집니다. (프로세스의 상태 정보(레지스터, PC 등)를 저장/복원하는 비용뿐 아니라, 캐시 무효화(cache invalidation)나 TLB flush 같은 부가 비용도 포함됩니다.)
    > **- 캐시 무효화(Cache Invalidation)란?** 컨텍스트 스위칭 시, 이전 프로세스가 사용하던 CPU 캐시의 데이터가 더 이상 유효하지 않게 되는 현상입니다. 이로 인해 새로운 프로세스는 필요한 데이터를 캐시에서 찾지 못하고(캐시 미스), 더 느린 메인 메모리에서 가져와야 하므로 초기 실행 속도가 저하됩니다.<br>
    > **- TLB (Translation Lookaside Buffer)란?** MMU 안에 있는 작은 고속 캐시로, 최근에 사용된 가상-물리 주소 변환 정보를 저장합니다. TLB에 정보가 있으면 페이지 테이블을 매번 찾아보지 않아도 되므로 주소 변환 속도가 매우 빨라집니다.<br>
    > **- TLB Flush란?** 컨텍스트 스위칭 시, 이전 프로세스의 주소 변환 정보가 담긴 TLB를 모두 비우는 작업을 말합니다. 이로 인해 새로운 프로세스는 처음부터 주소 변환 정보를 다시 만들어가야 하므로 초기 성능 저하가 발생합니다.
  - 시간 할당량이 너무 길면 FCFS와 유사하게 동작하여 응답성이 떨어질 수 있습니다.

### 마. 다단계 큐 스케줄링 (Multilevel Queue Scheduling)

준비 큐(Ready Queue)를 여러 개의 독립적인 큐로 분리하여, 각 큐마다 다른 스케줄링 알고리즘을 적용하는 방식입니다.

- **핵심 아이디어:** 프로세스를 성격에 따라 여러 그룹으로 나누어 관리합니다. 예를 들어, 대화형 작업을 위한 **전경(foreground) 큐**와 배치 작업을 위한 **후순위(background) 큐**로 나눌 수 있습니다.
- **동작 방식:**
  - 전경 큐는 응답성이 중요한 RR 방식을 사용하고, 후순위 큐는 효율성이 중요한 FCFS 방식을 사용할 수 있습니다.
  - 큐와 큐 사이에도 우선순위 기반의 스케줄링이 적용됩니다. (예: 전경 큐가 모두 비어 있을 때만 후순위 큐를 실행)
- **장점:**
  - 프로세스의 특성에 맞게 스케줄링 방식을 다르게 적용하여 시스템의 요구사항을 만족시키기 용이합니다.
- **단점:**
  - 한 번 특정 큐에 할당되면 다른 큐로 이동할 수 없어, 유연성이 떨어질 수 있습니다. (이 단점을 보완하여 큐 간 이동을 가능하게 만든 것이 바로 아래 '심화' 섹션에서 다룰 <b>다단계 피드백 큐(MLFQ)</b>입니다.)

## 3. 알고리즘 비교

| 알고리즘 | 핵심 아이디어 | 스케줄링 방식 | 장점 | 단점 |
| --- | --- | --- | --- | --- |
| **FCFS** | 먼저 온 순서대로 | 비선점 | 구현 간단 | 호송 효과, 응답 시간 김 |
| **SJF/SRTF** | 가장 짧은 작업부터 | 비선점/선점 | 평균 대기 시간 최소화 | 실행 시간 예측 어려움, 기아 현상 |
| **우선순위** | 우선순위가 높은 순서대로 | 선점/비선점 | 중요 작업 선처리 | 기아 현상 |
| **RR** | 정해진 시간만큼씩 순환 | 선점 | 공정성, 빠른 응답 시간 | 컨텍스트 스위칭 오버헤드 |
| **다단계 큐**| 그룹별 큐 분리 | 혼합형 | 유연성 | 큐 이동 불가, 경직성 |

--- 
* **비선점(Non-preemptive):** 한 프로세스가 CPU를 점유하면 작업이 끝날 때까지 다른 프로세스가 끼어들 수 없음.
* **선점(Preemptive):** 우선순위가 더 높은 프로세스가 현재 실행 중인 프로세스를 중단시키고 CPU를 차지할 수 있음.

## 4. 심화: 현대 운영체제와 스케줄링

- **멀티코어 스케줄링:** 현대의 멀티코어 환경에서는 각 코어에 작업을 어떻게 배분할지 결정하는 것이 중요합니다. 모든 코어가 균등하게 일하도록 부하를 분산하는 **로드 밸런싱(Load Balancing)** 기법이 함께 고려되어야 합니다. 반대로, 특정 프로세스를 특정 코어에 고정시키는 **CPU 친화성(CPU Affinity)** 전략을 사용하여 캐시 재사용률을 높이고 성능을 최적화하기도 합니다.

- **실제 운영체제 사례:**
  - **Linux - CFS(Completely Fair Scheduler):** 각 프로세스의 '가상 실행 시간(vruntime)'을 기준으로 스케줄링합니다. vruntime은 실제 실행 시간에 우선순위 가중치를 반영하여 계산되며, CFS는 이 vruntime이 가장 작은 프로세스(가장 적게 실행된 것으로 간주)를 Red-Black Tree에서 찾아 다음에 실행함으로써 공정성을 유지합니다. (시간 복잡도 O(log N))
  - **Windows - MLFQ(Multilevel Feedback Queue):** 다단계 큐의 발전된 형태로, 프로세스가 큐 사이를 이동할 수 있습니다. 짧은 CPU burst time을 가진 대화형 작업은 높은 우선순위 큐에서 빠르게 처리되고, CPU를 오래 점유하는 연산 위주의 긴 작업(배치 작업)은 점차 낮은 우선순위 큐로 이동합니다. 반면, I/O 작업을 수행하고 돌아온 프로세스는 다시 높은 우선순위 큐에 배치되어 빠른 응답을 보장받습니다. 이를 통해 대화형 작업과 배치 작업을 동적으로 분리하여 시스템의 반응성과 처리율을 동시에 만족시킵니다.
    > **- CPU Burst Time이란?** 프로세스가 CPU를 연속적으로 사용하는 시간을 의미합니다. I/O를 자주 하는 대화형 작업은 CPU burst time이 짧고, 복잡한 연산을 하는 작업은 CPU burst time이 깁니다.

- **실시간 시스템 스케줄링:** 정해진 시간(deadline) 안에 작업을 반드시 끝내야 하는 실시간 시스템에서는 <b>RMS(Rate Monotonic Scheduling)</b>나 **EDF(Earliest Deadline First)** 같은 알고리즘이 사용됩니다. 이러한 알고리즘은 평균 성능보다 **'마감 시간(deadline)' 준수**를 최우선 목표로 하며, 예측 가능성이 가장 중요합니다. 예를 들어, EDF에서는 deadline이 가장 임박한 태스크를 먼저 실행하며, 이는 RMS보다 더 유연하지만 스케줄러가 더 복잡해지고 오버헤드가 증가할 수 있습니다. 따라서 실제 시스템 적용 전, 모든 태스크가 마감 시간 내에 완료될 수 있는지 수학적으로 검증하는 'Shedulability Test' 과정이 필수적입니다. (예를 들어, RMS에서는 모든 태스크가 주기적이고 deadline이 주기와 같을 경우, Liu & Layland의 이용률(utilization) 기반 공식으로 스케줄 가능성을 간단히 판별할 수 있습니다.)