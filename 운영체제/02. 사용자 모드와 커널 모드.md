# 사용자 모드와 커널 모드 (User Mode & Kernel Mode)

## 1. 듀얼 모드(Dual Mode)란?

운영체제는 시스템의 안정성과 보안을 위해 CPU의 실행 모드를 **사용자 모드**와 **커널 모드** 두 가지로 구분하여 사용합니다. 이를 **듀얼 모드**라고 하며, 이는 프로세스가 접근할 수 있는 자원을 제한하고 시스템의 핵심 기능을 보호하는 데 핵심적인 역할을 합니다. 이러한 분리는 메모리 보호, 권한 검증 등과 함께 작동하여 악성 코드가 시스템의 핵심 자원에 직접 접근하는 것을 원천적으로 차단하는 핵심적인 보안 장치 역할을 합니다.

## 2. 사용자 모드 (User Mode)

일반적인 응용 프로그램(Application)이 실행되는 환경으로, **제한된 권한**만을 가집니다.

- **특징:**
  - 하드웨어나 메모리 같은 시스템의 중요 자원에 직접 접근할 수 없습니다.
  - 다른 프로세스의 메모리 공간을 침범할 수 없습니다.
  - 시스템 자원을 사용하려면, 운영체제에게 <b>시스템 콜(System Call)</b>을 통해 서비스를 요청해야 합니다.
- **목적:**
  - 하나의 사용자 프로그램이 오류나 악의적인 행위로 인해 전체 시스템을 중단시키거나 손상시키는 것을 방지합니다. (시스템 안정성 및 보안)

## 3. 커널 모드 (Kernel Mode)

운영체제의 핵심 기능이 실행되는 환경으로, **모든 자원에 대한 접근 권한**을 가집니다.

- **특징:**
  - CPU, 메모리, 디스크 등 모든 컴퓨터 자원에 직접 접근하고 제어할 수 있습니다.
  - 운영체제의 핵심 코드(커널)가 이 모드에서 실행됩니다.
  - 메모리 관리, 프로세스 스케줄링, 디바이스 드라이버 실행 등 시스템의 모든 핵심 작업이 커널 모드에서 처리됩니다.
- **목적:**
  - 시스템의 모든 부분을 관리하고 제어하기 위한 전적인 권한을 확보합니다.

## 4. 모드 전환: 시스템 콜 (System Call)

사용자 모드에서 실행되는 프로그램이 디스크 입출력이나 네트워크 통신과 같이 커널의 도움이 필요한 작업을 수행하려면, **시스템 콜**이라는 인터페이스를 통해 커널에게 요청을 보냅니다.

- **처리 과정:**
  1. 사용자 프로세스가 시스템 콜을 호출합니다.
  2. CPU는 **사용자 모드에서 커널 모드로 전환**하고, 커널은 요청받은 작업을 수행합니다.
  3. 작업이 완료되면, CPU는 다시 **커널 모드에서 사용자 모드로 전환**하여 결과를 반환하고, 사용자 프로세스는 실행을 이어갑니다.

- **모드 전환의 비용:** 사용자 모드와 커널 모드를 전환하는 과정은 CPU의 상태를 저장하고 복원하는 작업을 포함하므로, 단순한 함수 호출보다 훨씬 큰 비용(overhead)이 발생합니다. 따라서 잦은 시스템 콜은 성능 저하의 원인이 될 수 있으며, 이를 줄이기 위해 여러 시스템 콜을 하나로 묶어 처리하거나, Linux의 <b>vDSO(Virtual Dynamic Shared Object)</b>처럼 일부 시스템 콜을 사용자 공간에 매핑하여 모드 전환 없이 처리하는 등의 최적화 기법이 사용되기도 합니다.

> **- 시스템 콜(System Call)이란?** 사용자 모드의 프로그램이 커널 모드의 기능을 사용할 수 있도록 운영체제가 제공하는 유일한 통로(인터페이스)입니다.<br>
> **- 트랩(Trap) vs. 인터럽트(Interrupt):** 시스템 콜은 사용자 프로그램이 **의도적으로** 커널 기능을 요청하며 <b>소프트웨어적인 트랩(Trap)</b>을 발생시켜 모드를 전환합니다. 반면, **인터럽트**는 하드웨어(e.g., 키보드 입력, 디스크 I/O 완료)나 예외 상황(e.g., 0으로 나누기)에 의해 **비동기적으로** 발생하는 이벤트로, 이를 처리하기 위해 커널 모드로 전환된다는 차이가 있습니다.

## 5. 비교 및 실무 예시

| 구분 | 사용자 모드 (User Mode) | 커널 모드 (Kernel Mode) |
| :--- | :--- | :--- |
| **실행 주체** | 일반 응용 프로그램 (e.g., 웹 브라우저, 게임 엔진) | 운영체제(OS) 커널 |
| **접근 권한** | 제한적 (하드웨어 직접 접근 불가) | 모든 자원 접근 가능 |
| **자원 사용** | 시스템 콜을 통해 간접적으로 요청 | 직접 접근 및 제어 |
| **보안/안정성**| 높음 | 상대적으로 낮음 (커널 코드의 버그는 시스템 전체를 중단시킬 수 있음. e.g., 드라이버 오류로 인한 블루스크린) |

- **실무 예시:**
  - **게임 엔진:** 일반적으로 **사용자 모드**에서 실행됩니다. 그래픽 처리, 물리 연산 등은 제한된 권한 내에서 동작하며, 파일 저장이나 네트워크 통신은 시스템 콜을 통해 OS에 요청합니다.
  - **그래픽 드라이버:** 그래픽 카드(하드웨어)와 직접 통신해야 하므로 **커널 모드**에서 실행됩니다.

## 6. 심화: 현대 운영체제의 발전 방향

이처럼 두 모드의 분리는 시스템의 안정성과 성능 사이의 균형을 맞추는 핵심적인 설계 원리입니다. 더 나아가 현대 운영체제는 커널의 안정성을 더욱 높이기 위해, 과거에는 커널 모드에서만 실행되던 일부 기능(특히 디바이스 드라이버)을 사용자 모드에서 실행하는 방향으로 발전하고 있습니다.

- **예시:** Windows의 <b>사용자 모드 드라이버 프레임워크(UMDF, User-Mode Driver Framework)</b>는 드라이버가 사용자 모드에서 실행되도록 하여, 드라이버에 버그가 있더라도 전체 시스템이 다운되는 것을 방지하고 안정성을 크게 향상시킵니다. (다만, 사용자 모드 드라이버는 안정성이 높은 대신, 성능이나 하드웨어 접근 속도 면에서는 커널 모드 드라이버보다 일부 제약이 있을 수 있습니다.)