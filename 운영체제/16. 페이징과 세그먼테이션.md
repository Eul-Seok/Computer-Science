# 페이징과 세그먼테이션

페이징(Paging)과 세그먼테이션(Segmentation)은 운영체제가 프로세스의 논리 주소 공간을 물리 메모리에 매핑하고 관리하는 주요 메모리 관리 기법입니다. 이 두 기법은 메모리 단편화 문제를 해결하고, 다중 프로그래밍 환경에서 메모리를 효율적으로 사용하기 위해 고안되었습니다.

## 1. 페이징 (Paging)

페이징은 프로세스의 논리 주소 공간을 <b>고정된 크기의 블록(페이지, Page)</b>으로 나누고, 물리 메모리 또한 <b>동일한 크기의 블록(페이지 프레임, Page Frame)</b>으로 나눈 후, 페이지들을 페이지 프레임에 불연속적으로 배치하는 기법입니다.

### 1.1. 동작 원리

1.  **논리 주소 분할:** CPU가 생성하는 논리 주소는 페이지 번호(Page Number)와 페이지 오프셋(Page Offset)으로 나뉩니다.
2.  **페이지 테이블:** 운영체제는 각 프로세스마다 <b>페이지 테이블(Page Table)</b>을 유지합니다. 페이지 테이블은 논리 주소의 페이지 번호를 물리 메모리의 페이지 프레임 번호로 매핑하는 정보를 담고 있습니다.
3.  **물리 주소 변환:** 페이지 번호를 페이지 테이블에서 찾아 해당 페이지가 매핑된 페이지 프레임 번호를 얻고, 여기에 페이지 오프셋을 더하여 최종 물리 주소를 생성합니다.
4.  **TLB (Translation Lookaside Buffer):** 페이지 테이블 검색 속도를 높이기 위해 CPU 내부에 TLB라는 고속 캐시 메모리를 사용합니다.

### 1.2. 장점 및 단점

*   **장점:**
    *   **외부 단편화(External Fragmentation) 없음:** 물리 메모리를 고정된 크기로 나누어 사용하므로, 메모리 할당 시 외부 단편화가 발생하지 않습니다.
    *   **간단한 메모리 관리:** 페이지 프레임 단위로 메모리를 관리하므로 구현이 비교적 간단합니다.
*   **단점:**
    *   **내부 단편화(Internal Fragmentation) 발생:** 프로세스의 마지막 페이지가 페이지 프레임을 완전히 채우지 못할 경우 남는 공간이 발생합니다.
    *   **페이지 테이블 오버헤드:** 각 프로세스마다 페이지 테이블을 유지해야 하므로, 페이지 테이블 자체를 저장하는 데 메모리 공간이 필요합니다.

## 2. 세그먼테이션 (Segmentation)

세그먼테이션은 프로세스의 논리 주소 공간을 <b>의미 있는 논리적 단위(세그먼트, Segment)</b>로 나누어 물리 메모리에 배치하는 기법입니다. 각 세그먼트는 코드, 데이터, 스택, 서브루틴 등 프로그램의 논리적 구조에 따라 크기가 가변적입니다.

### 2.1. 동작 원리

1.  **논리 주소 분할:** CPU가 생성하는 논리 주소는 세그먼트 번호(Segment Number)와 세그먼트 오프셋(Segment Offset)으로 나뉩니다.
2.  **세그먼트 테이블:** 운영체제는 각 프로세스마다 <b>세그먼트 테이블(Segment Table)</b>을 유지합니다. 세그먼트 테이블은 각 세그먼트의 시작 물리 주소(Base Address)와 크기(Limit) 정보를 담고 있습니다.
3.  **물리 주소 변환:** 세그먼트 번호를 세그먼트 테이블에서 찾아 해당 세그먼트의 시작 주소를 얻고, 여기에 세그먼트 오프셋을 더하여 최종 물리 주소를 생성합니다. 이때 오프셋이 세그먼트 크기를 초과하는지 검사하여 메모리 보호를 수행합니다.

### 2.2. 장점 및 단점

*   **장점:**
    *   **논리적 메모리 관리:** 프로그램의 논리적 구조에 맞춰 메모리를 관리하므로, 프로그래머에게 더 직관적인 메모리 뷰를 제공합니다.
    *   **메모리 보호 용이:** 각 세그먼트별로 접근 권한(읽기, 쓰기, 실행)을 설정하여 메모리 보호를 강화할 수 있습니다. 예를 들어, 다음과 같이 권한을 부여할 수 있습니다.
        *   **코드 세그먼트(Code Segment):** 읽기(Read) 및 실행(Execute) 권한만 부여하여, 프로그램 실행 중에 코드가 실수로 변경되는 것을 방지합니다.
        *   **데이터 세그먼트(Data Segment):** 읽기(Read) 및 쓰기(Write) 권한을 부여하지만, 실행(Execute) 권한은 제거하여 데이터 영역에 악성 코드가 주입되어 실행되는 것을 막습니다.
        *   **스택 세그먼트(Stack Segment):** 읽기(Read) 및 쓰기(Write) 권한을 부여합니다.
*   **단점:**
    *   **외부 단편화(External Fragmentation) 발생:** 가변 크기 할당으로 인해 메모리 중간에 사용 불가능한 작은 빈 공간들이 생길 수 있습니다.
    *   **복잡한 메모리 관리:** 가변적인 세그먼트 크기 때문에 메모리 할당 및 회수 알고리즘이 페이징보다 복잡합니다.

## 3. 페이징과 세그먼테이션의 비교

두 기법의 차이를 시각적으로 비유하자면, **페이징**은 크기는 같지만 색깔만 다른 벽돌들로 집을 짓는 것과 같고, **세그먼테이션**은 '거실', '안방', '주방'처럼 크기와 용도가 각기 다른 공간들로 집의 구조를 설계하는 것과 같습니다. 페이징은 관리의 용이성에, 세그먼테이션은 설계의 유연성과 의미 부여에 중점을 둡니다.

| 구분 | 페이징 (Paging) | 세그먼테이션 (Segmentation) |
| :--- | :--- | :--- |
| **메모리 분할 단위** | 고정 크기 (페이지) | 가변 크기 (세그먼트) |
| **논리적 관점** | 사용자에게 투명 (운영체제가 관리) | 사용자에게 의미 있는 단위 (코드, 데이터 등) |
| **단편화** | 내부 단편화 발생, 외부 단편화 없음 | 외부 단편화 발생 가능, 내부 단편화 없음 |
| **주소 변환** | 페이지 테이블 사용 | 세그먼트 테이블 사용 |
| **메모리 보호** | 페이지 단위 | 세그먼트 단위 (더 세밀한 제어 가능) |
| **구현 복잡도** | 비교적 간단 | 비교적 복잡 |

## 4. 혼합 기법: 페이징 기반 세그먼테이션

현대 운영체제는 페이징과 세그먼테이션의 장점을 결합한 혼합 기법을 사용하기도 합니다. 대표적인 예가 <b>페이징 기반 세그먼테이션(Paged Segmentation)</b>입니다.

*   **동작 방식:** 먼저 프로그램을 논리적인 세그먼트(코드, 데이터, 스택 등)로 나눈 뒤, 각 세그먼트를 다시 고정된 크기의 페이지들로 나눕니다.
*   **장점:**
    *   세그먼테이션의 장점인 **논리적 단위 관리와 메모리 보호** 기능을 유지합니다.
    *   페이징의 장점인 **간편한 메모리 할당과 외부 단편화 문제 해결** 능력을 가집니다.
*   **결과:** 유연성과 관리의 용이성을 동시에 확보할 수 있어, 많은 시스템에서 이와 유사한 메모리 관리 구조를 채택하고 있습니다.

## 5. 게임 개발 및 C++에서의 응용

운영체제 수준의 페이징과 세그먼테이션은 개발자에게 대부분 투명하게 처리되지만, 그 기본 원리는 게임 엔진의 메모리 관리 전략을 설계하는 데 중요한 영감을 줍니다.

*   **가상 메모리 활용:** 대규모 오픈 월드 게임은 페이징 기반 가상 메모리 시스템 덕분에 물리 메모리보다 훨씬 큰 월드를 다룰 수 있습니다. 다만, 잦은 페이지 폴트는 성능 저하를 유발하므로 데이터 지역성을 고려한 설계가 필수적입니다.
*   **C++에서의 세그먼테이션 개념 응용:** C++ 프로그래머는 세그먼테이션의 '의미 단위 관리' 개념을 차용하여 고성능 메모리 관리 기법을 구현합니다. <b>커스텀 할당자(`std::allocator`, `std::pmr`)</b>나 **`new`/`delete` 연산자 오버라이딩**을 통해, 특정 타입의 객체들(예: 총알, 파티클, 적 캐릭터)만을 위한 전용 메모리 풀(Memory Pool)을 만듭니다. 이는 일종의 'Bullet Segment', 'Particle Segment'처럼 논리적인 메모리 구획을 만드는 것과 같습니다. 이러한 전략은 다음과 같은 이점을 가집니다.
    *   **성능 향상:** 일반 힙 할당/해제보다 훨씬 빠릅니다.
    *   **단편화 감소:** 고정 크기 객체들을 모아 관리하므로 메모리 단편화가 줄어듭니다.
    *   **지역성 개선:** 동일한 타입의 객체들이 메모리에 인접하게 배치되어 CPU 캐시 효율이 극대화됩니다.

결론적으로, 개발자는 운영체제의 메모리 관리 기법을 이해함으로써, 더 높은 수준에서 메모리 사용을 최적화하고 애플리케이션의 성능을 극대화할 수 있습니다.

---