# 가상 메모리와 페이지 폴트 (Virtual Memory & Page Fault)

## 1. 가상 메모리(Virtual Memory)란?

가상 메모리는 운영체제가 제공하는 메모리 관리 기법으로, 물리적 메모리(RAM)의 실제 크기보다 더 큰 주소 공간을 프로그램에 제공하는 기술입니다.

- **핵심 아이디어:** 프로그램의 모든 부분이 항상 물리 메모리에 있을 필요는 없다는 점에서 착안했습니다. 필요한 부분만 RAM에 올리고, 나머지는 디스크(스왑 영역)에 저장해 둡니다.
    > **- 스왑 영역(Swap Space):** RAM이 부족할 때, 당장 쓰이지 않는 페이지를 임시로 저장해두는 디스크(HDD/SSD)의 특정 공간입니다. RAM을 '작업 책상', 스왑 영역을 '책상 옆 서랍'에 비유할 수 있습니다.
- **장점:**
  - 각 프로세스는 자신만의 독립적인 가상 주소 공간을 가지므로 메모리 침범이 방지됩니다. (메모리 보호)
  - 물리 메모리보다 큰 프로그램을 실행할 수 있습니다.
  - 여러 프로세스가 메모리를 효율적으로 공유하고 사용할 수 있습니다.

> **- 가상 주소(Virtual Address):** 프로세스가 참조하는 논리적인 주소.<br>
> **- 물리 주소(Physical Address):** 실제 메인 메모리(RAM) 상의 주소.

## 2. 페이지 폴트(Page Fault)란?

프로그램이 접근하려는 데이터가 현재 물리 메모리(RAM)에 없고 디스크에 있을 경우, 이를 메모리로 가져오는 과정에서 발생하는 **예외(Exception)** 상황입니다. 페이지 폴트는 오류가 아니라, 가상 메모리 시스템의 정상적인 동작 과정 중 하나입니다.

페이지 폴트는 비용에 따라 다음과 같이 구분할 수 있습니다.
- **Soft Page Fault:** 해당 페이지가 물리 메모리에는 없지만, 다른 프로세스의 메모리 공간이나 OS의 파일 시스템 캐시 등 **메모리 내 다른 곳에 있어** 디스크 I/O 없이 빠르게 처리 가능한 경우입니다.
- **Hard Page Fault:** 해당 페이지가 디스크(**스왑 영역**)에 있어, **느린 디스크 I/O가 반드시 수반되는** 경우입니다. 일반적으로 '페이지 폴트'라고 하면 이 경우를 의미하며, 성능 저하의 주된 원인이 됩니다.

## 3. 페이지 폴트 처리 과정

페이지 폴트가 발생하면, CPU는 하던 일을 잠시 멈추고 운영체제에 제어권을 넘겨 다음과 같은 과정을 순차적으로 진행합니다.

1.  **CPU의 메모리 접근 시도**
    - 프로그램이 특정 가상 주소에 접근을 시도합니다.

2.  **MMU의 주소 변환 및 폴트 감지**
    - CPU는 **MMU(메모리 관리 장치)** 에게 가상 주소를 물리 주소로 변환해달라고 요청합니다.
    - MMU는 먼저 고속 캐시인 **TLB(Translation Lookaside Buffer)** 에서 해당 주소 변환 정보가 있는지 확인합니다.
    - TLB에 정보가 없으면(TLB Miss), MMU는 **페이지 테이블**을 참조하여 물리 주소를 찾습니다.
    - 이때 페이지 테이블에 해당 페이지가 물리 메모리에 없다고 표시되어 있으면(invalid bit), MMU는 CPU에 **페이지 폴트 트랩(Trap)** 을 발생시킵니다.
      > **- MMU(Memory Management Unit):** 가상 주소를 물리 주소로 변환하고, 메모리 접근 권한을 확인하는 하드웨어 장치.<br>
      > **- TLB(Translation Lookaside Buffer):** 최근에 사용된 주소 변환 정보를 저장하는 MMU 내의 작은 고속 캐시.<br>
      > **- 페이지 테이블(Page Table):** 가상 주소와 물리 주소의 매핑 정보를 담고 있는 자료구조. 각 프로세스마다 하나씩 존재합니다.<br>
      > **- TLB Miss vs. Page Fault:** 이 둘은 다른 개념입니다. **TLB Miss**는 단순히 주소 변환 정보가 TLB 캐시에 없어 페이지 테이블을 참조해야 하는 상황(메모리 접근 1~2회)입니다. 반면 **Page Fault**는 페이지 테이블을 확인한 결과, 해당 페이지 자체가 물리 메모리에 없어 디스크 접근이 필요할 수 있는 훨씬 더 비용이 큰 상황을 의미합니다.

3.  **운영체제의 페이지 폴트 처리**
    - 페이지 폴트 인터럽트가 발생하면, 운영체제는 해당 페이지를 디스크(**스왑 영역**)에서 찾아 빈 **페이지 프레임**으로 가져옵니다.
    - 만약 빈 프레임이 없다면, **페이지 교체 알고리즘**(e.g., LRU, Clock)을 사용해 기존에 있던 페이지 중 하나를 디스크로 내보내고 공간을 확보합니다.
      > **- 페이지 프레임(Page Frame):** 물리 메모리를 페이지와 같은 크기로 나눈 블록.

4.  **페이지 테이블 갱신**
    - 페이지를 메모리에 성공적으로 올리면, 운영체제는 페이지 테이블을 갱신하여 새로운 물리 주소를 기록하고, 유효 비트(valid bit)를 1로 설정합니다.

5.  **CPU 명령 재실행**
    - 운영체제는 CPU에게 제어권을 돌려주고, 중단되었던 원래의 명령을 다시 실행합니다.
    - 이제 MMU는 (필요시 TLB를 갱신한 후) 페이지 테이블에서 유효한 물리 주소를 찾을 수 있으므로, 메모리 접근이 정상적으로 성공합니다.

## 4. 결론 및 심화

가상 메모리와 페이지 폴트 메커니즘 덕분에 프로그램은 물리 메모리의 제약 없이 큰 주소 공간을 사용할 수 있습니다. 하지만 페이지 폴트, 특히 Hard Page Fault가 너무 자주 발생하면 디스크 I/O로 인해 시스템 성능이 급격히 저하될 수 있습니다. 따라서 운영체제는 이를 최소화하기 위해 다음과 같은 전략을 사용합니다.

- **페이지 교체 알고리즘 최적화:** 앞서 배운 LRU, Clock 알고리즘 등을 통해 앞으로 사용될 가능성이 낮은 페이지를 교체하여 페이지 폴트 발생 확률을 줄입니다.

- **페이지 테이블 구조 확장:** 64비트 시스템처럼 주소 공간이 매우 큰 환경에서는 페이지 테이블 자체의 크기가 너무 커지는 문제가 있습니다. 이를 해결하기 위해 다음과 같은 기법을 사용합니다.
  - **다단계 페이지 테이블(Multi-level Page Table):** 페이지 테이블을 여러 단계로 나누어 계층화하는 방식입니다. 예를 들어 2단계 구조에서는, 가상 주소의 상위 비트로 외부 페이지 테이블(디렉터리)의 인덱스를 찾고, 그 결과로 얻은 내부 페이지 테이블의 주소를 하위 비트로 다시 인덱싱하여 최종 물리 프레임을 찾습니다. 이를 통해 사용되지 않는 페이지 테이블 영역은 생성조차 하지 않아 메모리를 절약할 수 있습니다.
  - **인버티드 페이지 테이블(Inverted Page Table):** 프로세스별로 페이지 테이블을 두는 대신, 시스템 전체에 물리 프레임 기준의 테이블을 하나만 두는 방식입니다. 이는 메모리 사용량을 획기적으로 줄이지만, 주소 변환 시 테이블 전체를 탐색해야 할 수 있어 해시 테이블을 함께 사용하여 성능 저하를 완화합니다.

- **페이지 폴트 빈도(PFF) 기반 메모리 조절:** 운영체제는 특정 프로세스의 페이지 폴트 빈도(PFF, Page Fault Frequency)를 지속적으로 감시하여 메모리 할당량을 동적으로 조절합니다. PFF가 설정된 상한선보다 높으면 해당 프로세스의 워킹셋에 비해 할당된 프레임이 부족하다고 판단하여 프레임을 더 할당해줍니다. 반대로 PFF가 하한선보다 낮으면, 필요 이상으로 많은 메모리를 점유하고 있다고 보고 할당된 프레임을 회수하여 시스템 전체의 메모리 균형을 유지합니다.

- **프리페칭 (Prefetching):** 프로그램이 특정 페이지를 요청할 때, 앞으로 필요할 것으로 예상되는 인접 페이지들을 미리 메모리에 올려두는 기법입니다.

- **워킹셋 모델 (Working Set Model):** 프로세스가 특정 시간 동안 자주 참조하는 페이지들의 집합(Working Set)을 파악하고, 이 집합만큼은 항상 물리 메모리에 유지되도록 보장하여 페이지 폴트를 줄이는 전략입니다.