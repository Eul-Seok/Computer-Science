# 스레드 제어 블록 (TCB, Thread Control Block)

## 1. TCB란 무엇인가?

<b>TCB(Thread Control Block)</b>는 프로세스 내에서 각각의 스레드를 관리하기 위해 필요한 정보를 담고 있는 자료구조입니다. PCB가 '프로세스의 명함'이라면, TCB는 **'스레드의 개인 사물함'** 에 비유할 수 있습니다.

-   하나의 프로세스 내에 여러 스레드가 존재할 경우, 각 스레드는 자신만의 고유한 TCB를 갖습니다.
-   운영체제는 이 TCB를 통해 스레드의 상태를 추적하고, 스레드 간의 문맥 전환을 수행합니다.

## 2. TCB에 저장되는 주요 정보

TCB는 스레드가 독립적으로 실행되기 위한 최소한의 정보를 저장합니다.

-   **스레드 식별자 (TID):** 프로세스 내에서 각 스레드를 고유하게 식별하는 번호.
-   **스레드 상태 (Thread State):** 스레드의 현재 상태 (e.g., 준비, 실행, 대기 등).
-   **프로그램 카운터 (Program Counter):** 스레드가 다음에 실행할 명령어의 주소.
-   **CPU 레지스터:** 스레드의 이전 실행 시점의 레지스터 값들.
-   **스택 포인터 (Stack Pointer):** 스레드 자신만의 독립적인 실행 스택을 가리키는 포인터. 함수 호출, 지역 변수 등이 이 스택에 저장됩니다.
    > **스택(Stack)이란?** 함수가 호출될 때마다 해당 함수의 지역 변수, 매개변수, 복귀 주소 등을 저장하는 LIFO(Last-In, First-Out) 방식의 메모리 영역입니다. 각 스레드는 자신만의 독립적인 스택을 가지므로, 서로 다른 스레드가 같은 함수를 호출해도 변수가 섞이지 않습니다.

## 3. PCB vs TCB: 역할과 관계

PCB와 TCB는 프로세스와 스레드의 관계처럼, '자원 소유'와 '실행'이라는 역할로 명확히 구분됩니다.

-   **PCB (프로세스 제어 블록):**
    -   **역할:** 프로세스의 **자원**을 관리합니다.
    -   **포함 정보:** 메모리 공간(Code, Data, Heap), 열린 파일 목록, 프로세스 상태 등.
    > - **Code 영역:** 실행 가능한 기계어 코드가 저장되는 공간입니다.
    > - **Data 영역:** 전역 변수나 정적(static) 변수 등 프로그램 시작 시 할당되는 데이터가 저장됩니다.
    > - **Heap 영역:** 프로그래머가 직접 할당/해제하는 동적 메모리 공간입니다. (e.g., `malloc`, `new`)
    -   **비유:** 여러 사람이 함께 사는 **집**. 집 주소, 가스, 전기 등은 모두가 공유합니다.

-   **TCB (스레드 제어 블록):**
    -   **역할:** 스레드의 **실행 상태**를 관리합니다.
    -   **포함 정보:** 프로그램 카운터, 레지스터, 스택 포인터 등 독립적인 실행에 필요한 정보.
    -   **비유:** 집 안에 있는 **각각의 방**. 각자의 방(TCB)에서 독립적으로 잠을 자거나 공부(실행)하지만, 거실이나 주방(프로세스 자원)은 함께 사용합니다.

> 즉, 하나의 PCB(집)라는 울타리 안에, 여러 개의 TCB(개인 방)가 존재할 수 있는 구조입니다. 모든 스레드는 PCB의 자원을 공유하지만, 실행은 각자의 TCB를 기반으로 독립적으로 이루어집니다.

## 4. 문맥 전환(Context Switch)과 TCB

문맥 전환 비용을 이해하는 데 TCB는 매우 중요합니다.

-   **스레드 간 문맥 전환 (같은 프로세스 내):**
    -   **전환 대상:** TCB 정보만 저장하고 복원하면 됩니다.
    -   **비용:** 매우 저렴하고 빠릅니다. 공유하고 있는 메모리 공간(PCB 자원)은 그대로 둔 채, 스레드의 실행 상태만 바꾸면 되기 때문입니다.

-   **프로세스 간 문맥 전환:**
    -   **전환 대상:** PCB와 TCB 정보를 모두 저장하고 복원해야 합니다.
    -   **비용:** 매우 비쌉니다. 메모리 구조 전체가 바뀌므로, 캐시 및 TLB 플러시 등 무거운 작업이 추가로 발생합니다.

이러한 비용 차이 때문에, 현대의 응용 프로그램들은 무거운 프로세스를 여러 개 만드는 대신, 하나의 프로세스 내에서 여러 개의 가벼운 스레드를 활용하는 멀티스레딩 방식을 선호합니다.
