# 경쟁 상태 (Race Condition)

경쟁 상태(Race Condition)는 둘 이상의 프로세스나 스레드가 **동시에 공유 자원에 접근**하여 데이터를 조작할 때, 접근 순서에 따라 실행 결과가 달라지는 상황을 의미합니다. 이는 시스템의 예측 불가능한 동작이나 데이터 손상으로 이어질 수 있어 반드시 방지해야 합니다.

## 1. 경쟁 상태의 발생 조건

경쟁 상태는 다음 세 가지 조건이 모두 충족될 때 발생할 가능성이 높습니다.

1.  **공유 자원 (Shared Resource):** 둘 이상의 프로세스나 스레드가 접근할 수 있는 변수, 메모리, 파일, 데이터베이스 등의 자원이 존재해야 합니다.
2.  **동시 접근 (Concurrent Access):** 여러 프로세스나 스레드가 동시에 이 공유 자원에 접근하려고 시도해야 합니다.
3.  **자원 변경 (Modification):** 공유 자원의 내용이 변경될 수 있어야 합니다 (읽기 전용 자원은 경쟁 상태를 유발하지 않습니다).

## 2. 임계 구역 (Critical Section)

경쟁 상태가 발생하는 코드 영역을 <b>임계 구역(Critical Section)</b>이라고 합니다. 임계 구역은 공유 자원에 접근하는 코드 블록으로, 한 번에 하나의 프로세스나 스레드만 진입하여 실행할 수 있도록 보장되어야 합니다.

## 3. 경쟁 상태 방지 및 동기화 도구

경쟁 상태를 방지하고 데이터의 일관성을 유지하기 위해서는 <b>동기화(Synchronization)</b> 메커니즘이 필수적입니다. 주요 동기화 도구는 다음과 같습니다.

*   **뮤텍스 (Mutex - Mutual Exclusion):**
    *   '상호 배제'를 의미하며, 임계 구역에 오직 하나의 스레드/프로세스만 접근하도록 강제하는 잠금(Lock) 메커니즘입니다.
    *   자원이 하나일 때 주로 사용되며, 임계 구역에 진입하기 전에 락을 획득하고, 임계 구역을 벗어날 때 락을 해제합니다.
*   **세마포어 (Semaphore):**
    *   공유 자원에 접근할 수 있는 프로세스/스레드의 최대 허용 개수를 나타내는 정수 변수입니다.
    *   자원이 여러 개일 때 사용되며, `P()` (wait) 연산으로 자원을 획득하고, `V()` (signal) 연산으로 자원을 반납합니다. 세마포어 값이 0이 되면 더 이상 자원을 획득할 수 없습니다.
*   **모니터 (Monitor):**
    *   뮤텍스와 조건 변수(Condition Variable)를 결합한 고수준 동기화 메커니즘입니다.
    *   데이터와 데이터를 조작하는 프로시저를 하나의 단위로 묶어, 한 번에 하나의 프로세스/스레드만 모니터 내의 프로시저를 실행할 수 있도록 보장합니다.
*   **원자적 연산 (Atomic Operations):**
    *   더 이상 나눌 수 없는 단일 연산으로, 중간에 다른 연산에 의해 방해받지 않음을 보장합니다.
    *   하드웨어 수준에서 지원되며, 간단한 변수 업데이트 등에 사용되어 경쟁 상태를 방지합니다.

### 동기화의 함정: 데드락 (Deadlock)

경쟁 상태를 해결하기 위해 사용하는 잠금(Lock) 메커니즘은 <b>데드락(Deadlock, 교착 상태)</b>이라는 또 다른 문제를 유발할 수 있습니다. 데드락은 둘 이상의 스레드가 서로가 점유한 자원을 기다리며 무한 대기 상태에 빠지는 것을 의미합니다. 예를 들어, 스레드 A가 자원 1을 잠근 채 자원 2를 기다리고, 스레드 B는 자원 2를 잠근 채 자원 1을 기다리는 상황입니다. 따라서 동기화 도구를 사용할 때는 데드락 발생 가능성을 항상 염두에 두어야 합니다.

## 4. C++ 기반의 경쟁 상태 및 해결 예시

C++11 표준부터 멀티스레딩을 정식으로 지원하면서 관련된 동기화 도구들이 표준 라이브러리에 포함되었습니다.

### 경쟁 상태가 발생하는 코드

```cpp
int counter = 0;

void increment() {
    for (int i = 0; i < 10000; ++i)
    {
        counter++; // 임계 구역
    }
}

int main()
{
    std::vector<std::thread> threads;
    for (int i = 0; i < 10; ++i)
    {
        threads.push_back(std::thread(increment));
    }

    for (auto& th : threads)
    {
        th.join();
    }

    // 기대값은 100000 이지만, 실제로는 그보다 훨씬 작은 값이 출력될 수 있다.
    std::cout << "Final counter: " << counter << std::endl;
    return 0;
}
```
`counter++` 연산은 실제로는 '메모리에서 값을 읽고, 레지스터에서 1을 더하고, 다시 메모리에 쓰는' 여러 단계의 기계어 명령으로 이루어집니다. 이 단계들 사이에 다른 스레드가 끼어들어 값을 변경하면, 일부 연산이 누락되어 최종 결과가 예측과 달라집니다.

### 해결 1: `std::mutex`와 `std::lock_guard` 사용

```cpp
int counter = 0;
std::mutex mtx; // 뮤텍스 객체

void increment()
{
    for (int i = 0; i < 10000; ++i)
    {
        // 임계 구역 시작, 자동으로 락
        std::lock_guard<std::mutex> lock(mtx); 
        counter++;
    } // lock_guard가 범위를 벗어나면서 자동으로 언락
}
// main 함수는 위와 동일
```
`std::lock_guard`는 생성될 때 뮤텍스를 잠그고, 소멸될 때(스코프를 벗어날 때) 자동으로 뮤텍스를 해제하는 RAII(Resource Acquisition Is Initialization) 객체입니다. 이를 통해 임계 구역을 안전하게 보호하고, 개발자가 직접 락을 해제하는 것을 잊어버리는 실수를 방지합니다.

### 해결 2: `std::atomic` 사용

단순한 정수 변수를 증가/감소시키는 경우, 뮤텍스보다 훨씬 가볍고 효율적인 `std::atomic`을 사용할 수 있습니다.

```cpp
std::atomic<int> counter = 0; // 원자적 연산을 지원하는 정수

void increment()
{
    for (int i = 0; i < 10000; ++i)
    {
        counter++; // 이 연산은 원자적으로 수행됨
    }
}
// main 함수는 위와 동일
```
`std::atomic`은 하드웨어 수준의 원자적 연산을 활용하여 락 없이도 스레드로부터 안전하게 값을 증감시킬 수 있습니다.

## 5. 게임 개발에서의 경쟁 상태와 동기화

게임 엔진은 복잡한 멀티스레드 환경에서 동작하며, 다양한 공유 자원(게임 상태, 물리 엔진 데이터, 렌더링 큐, 리소스 풀 등)을 사용하므로 경쟁 상태 발생 가능성이 매우 높습니다.

*   **공유 게임 상태:** 여러 스레드(예: AI 스레드, 물리 스레드, 렌더링 스레드)가 동시에 플레이어의 위치, 적의 상태, 점수 등 게임의 핵심 데이터를 업데이트하려고 할 때 경쟁 상태가 발생할 수 있습니다. 이는 게임 로직의 오류나 비정상적인 동작으로 이어집니다.
*   **리소스 관리:** 텍스처, 모델, 사운드 등의 리소스를 로드하거나 해제하는 스레드와 이를 사용하는 렌더링 스레드 간에 리소스 풀에 대한 경쟁 상태가 발생할 수 있습니다.
*   **렌더링 파이프라인:** 멀티스레드 렌더링에서 커맨드 버퍼나 렌더링 상태를 공유할 때 동기화 문제가 발생할 수 있습니다.
*   **물리 엔진:** 여러 오브젝트의 충돌 처리나 위치 업데이트가 동시에 이루어질 때, 공유되는 물리 데이터에 대한 경쟁 상태를 방지해야 합니다.

게임 개발자는 뮤텍스, 세마포어, 락프리(Lock-Free) 자료구조, 원자적 연산 등 다양한 동기화 기법을 사용하여 게임 엔진의 안정성과 성능을 확보해야 합니다. 특히, 동기화는 오버헤드를 발생시키므로, 불필요한 락을 피하고 최소한의 범위에서 효율적으로 적용하는 것이 중요합니다.

## 6. 동기화 성능 최적화 전략

동기화 메커니즘, 특히 락은 스레드를 대기시키고 컨텍스트 스위칭을 유발하는 등 상당한 성능 오버헤드를 가집니다. 따라서 동기화의 범위를 최소화하고 더 효율적인 방법을 찾는 것이 중요합니다.

*   **임계 구역 최소화 (Fine-Grained Locking):** 하나의 거대한 락으로 많은 데이터를 보호하기보다, 여러 개의 작은 락으로 각각의 데이터를 보호하여 락의 경합을 줄이는 전략입니다. 이를 통해 여러 스레드가 서로 다른 데이터를 동시에 수정할 수 있어 병렬성이 향상됩니다.
*   **읽기-쓰기 락 (Read-Write Lock):** 데이터를 변경하는 '쓰기' 작업은 배타적으로 수행되어야 하지만, 데이터를 읽기만 하는 '읽기' 작업은 여러 스레드가 동시에 수행해도 안전합니다. 읽기-쓰기 락(`std::shared_mutex` in C++)은 읽기 작업 간에는 락을 공유하고, 쓰기 작업 시에만 배타적 락을 거는 방식으로 성능을 최적화합니다. 읽기가 쓰기보다 훨씬 빈번한 경우에 매우 효과적입니다.
*   **락프리 프로그래밍 (Lock-Free Programming):** `std::atomic`과 같은 원자적 연산을 기반으로 락을 전혀 사용하지 않고 동기화를 구현하는 고급 기법입니다. 락으로 인한 데드락이나 성능 저하 문제는 없지만, 설계가 매우 복잡하고 ABA 문제 등 해결해야 할 난제가 많아 전문가 수준의 이해가 필요합니다.

---
