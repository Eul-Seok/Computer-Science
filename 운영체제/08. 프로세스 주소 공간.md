# 프로세스 주소 공간

프로세스 주소 공간은 운영체제가 하나의 프로세스에게 할당하는 **논리적 메모리 구조**입니다. 이는 프로세스가 실행될 때 참조하는 가상의 메모리 영역으로, 실제 물리 메모리와는 다르게 추상화된 공간입니다. 각 프로세스는 자신만의 독립적인 주소 공간을 가지므로, 다른 프로세스의 메모리 영역에 직접 접근할 수 없어 시스템의 안정성과 보안이 유지됩니다.

## 1. 프로세스 주소 공간의 구성 요소

일반적으로 프로세스 주소 공간은 다음과 같은 주요 영역으로 구성됩니다.

*   **코드 영역 (Text Segment):**
    *   프로그램의 실행 가능한 기계어 코드가 저장되는 공간입니다.
    *   읽기 전용(Read-Only)으로 설정되어 프로그램 코드의 변경을 방지하며, 여러 프로세스가 동일한 코드를 실행할 경우 이 영역을 공유하여 메모리 효율성을 높일 수 있습니다.
*   **데이터 영역 (Data Segment):**
    *   프로그램이 시작될 때 초기화되는 전역 변수(Global Variable), 정적 변수(Static Variable), 배열 등이 저장되는 공간입니다.
    *   프로그램이 실행되는 동안 값이 변경될 수 있으므로 읽기/쓰기(Read/Write)가 가능합니다.
*   **힙 영역 (Heap Segment):**
    *   프로그램 실행 중에 프로그래머가 명시적으로 요청하여 동적으로 할당되는 메모리 공간입니다.
    *   C/C++의 `malloc()`, `new` 연산자를 통해 할당되며, `free()`, `delete` 연산자를 통해 해제됩니다.
    *   런타임에 크기가 가변적으로 변할 수 있으며, 일반적으로 메모리의 **낮은 주소에서 높은 주소 방향으로** 할당됩니다(Grows upwards).
*   **스택 영역 (Stack Segment):**
    *   함수 호출 시 지역 변수(Local Variable), 매개변수(Parameter), 리턴 주소 등이 임시로 저장되는 공간입니다.
    *   함수가 호출될 때마다 스택 프레임이 생성되고, 함수가 반환되면 해당 스택 프레임이 해제되는 LIFO(Last-In, First-Out) 방식으로 동작합니다.
    *   컴파일 시 크기가 결정되며, 일반적으로 메모리의 **높은 주소에서 낮은 주소 방향으로** 할당됩니다(Grows downwards).

### 주소 공간의 성장 방향과 메모리 보호

힙은 낮은 주소에서 높은 주소로, 스택은 높은 주소에서 낮은 주소로 자라는 구조는 한정된 주소 공간을 효율적으로 사용하기 위함입니다. 두 영역 사이의 공간은 프로세스가 실행되는 동안 동적으로 변할 수 있습니다.

또한, 운영체제는 각 메모리 영역에 **접근 권한(읽기/쓰기/실행)**을 부여하여 메모리를 보호합니다. 예를 들어, 코드 영역은 '읽기/실행'만 가능하도록 설정하여 실수로 코드가 변경되는 것을 막고, 데이터/힙/스택 영역은 '읽기/쓰기'를 허용합니다. 이러한 메모리 보호 기법은 악성 코드나 버그로부터 시스템의 안정성을 지키는 핵심적인 역할을 합니다.

## 2. 논리 주소와 물리 주소

프로세스는 CPU에 의해 생성된 **논리 주소(Logical Address)**를 사용하며, 이 논리 주소는 운영체제의 메모리 관리 장치(MMU, Memory Management Unit)에 의해 실제 물리 메모리의 **물리 주소(Physical Address)**로 변환됩니다. 이러한 주소 변환 과정을 통해 각 프로세스는 독립적인 주소 공간을 가질 수 있으며, 다른 프로세스의 메모리 영역을 침범하지 못하도록 보호됩니다.

## 3. 게임 개발에서의 프로세스 주소 공간 관리

게임 개발에서는 메모리 사용의 효율성과 성능이 매우 중요하므로, 프로세스 주소 공간의 각 영역을 이해하고 적절히 활용하는 것이 필수적입니다.

*   **힙 영역 최적화:** 게임 오브젝트, 레벨 데이터, 텍스처 등 런타임에 동적으로 생성되는 많은 데이터는 힙 영역에 할당됩니다. 잦은 `malloc`/`free` 호출은 메모리 단편화(fragmentation)를 유발하고 성능 저하로 이어질 수 있습니다. 따라서 게임 엔진은 메모리 풀(Memory Pool)이나 커스텀 할당자(Custom Allocator)를 사용하여 힙 영역의 효율적인 관리를 시도합니다.
*   **스택 오버플로우 방지:** 재귀 함수 호출이 많거나 지역 변수가 너무 큰 경우 스택 오버플로우(Stack Overflow)가 발생할 수 있습니다. 게임에서는 복잡한 알고리즘이나 깊은 함수 호출 스택이 사용될 수 있으므로, 스택 사용량을 주의 깊게 관리해야 합니다.
*   **코드/데이터 공유:** 여러 게임 프로세스(예: 게임 클라이언트와 별도의 런처)가 동일한 코드나 읽기 전용 데이터를 공유하도록 설계하여 메모리 사용량을 줄일 수 있습니다.
*   **가상 메모리 활용:** 대규모 오픈 월드 게임 등에서는 모든 데이터를 물리 메모리에 올릴 수 없으므로, 운영체제의 가상 메모리 기능을 활용하여 필요한 부분만 물리 메모리에 로드하고 나머지는 디스크에 보관하는 전략을 사용합니다. 하지만 잦은 페이지 폴트(Page Fault)는 성능 저하를 유발하므로, 게임 개발자는 데이터 지역성(Data Locality)을 고려하여 메모리 접근 패턴을 최적화해야 합니다.

---