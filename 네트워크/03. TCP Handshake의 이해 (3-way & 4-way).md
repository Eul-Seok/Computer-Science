# 03. TCP Handshake의 이해 (3-way & 4-way)

TCP는 신뢰성 있는 데이터 전송을 위해 통신 전에 <b>연결을 설정(Connection Establishment)</b>하고, 통신이 끝나면 <b>연결을 해제(Connection Termination)</b>하는 과정을 거칩니다. 이 과정들을 각각 **3-way Handshake**와 **4-way Handshake**라고 부릅니다. 이 절차는 양측이 데이터 전송을 위한 준비가 되었는지 확인하고, 통신을 안전하게 종료하기 위한 핵심 메커니즘입니다.

## 1. 연결 설정: 3-way Handshake

3-way Handshake는 통신을 시작하기 전, 클라이언트와 서버가 서로에게 신뢰성 있는 연결을 설정하기 위한 3단계 과정입니다. 이 과정을 통해 양측은 초기 <b>시퀀스 번호(Sequence Number)</b>를 교환하고, 안정적인 데이터 전송 채널을 확보합니다.
> 시퀀스 번호: 데이터 패킷의 순서를 나타내는 고유 번호로, 데이터의 유실 및 중복을 방지하고 순서 유지를 위해 사용됩니다.

### 과정
1.  **[Client -> Server] SYN (Synchronize Sequence Numbers)**
    -   클라이언트는 서버에 접속을 요청하는 `SYN` 패킷을 보냅니다.
    -   이때 클라이언트는 자신의 초기 시퀀스 번호 `(client_isn)`를 함께 보냅니다.
    -   클라이언트는 `SYN_SENT` 상태로 전환되어 서버의 응답을 기다립니다.
    > SYN: 연결을 시작하기 위해 클라이언트가 서버에 보내는 첫 번째 제어 패킷입니다.

    > SYN_SENT: 클라이언트가 SYN 패킷을 보내고 서버의 SYN+ACK 응답을 기다리는 상태입니다.

2.  **[Server -> Client] SYN + ACK (Acknowledgment)**
    -   서버는 클라이언트의 `SYN` 패킷을 받고, 요청을 수락한다는 의미의 `ACK` 패킷과 자신도 연결을 준비했다는 `SYN` 패킷을 함께 보냅니다.
    -   `ACK` 패킷에는 클라이언트의 시퀀스 번호에 1을 더한 값 `(client_isn + 1)`을 담아 "당신의 요청을 잘 받았다"는 것을 알립니다.
    -   `SYN` 패킷에는 서버 자신의 초기 시퀀스 번호 `(server_isn)`를 담아 보냅니다.
    -   서버는 `SYN_RECEIVED` 상태로 전환됩니다.
    > ACK: 상대방으로부터 패킷을 잘 받았음을 알리는 제어 패킷입니다.

    > SYN_RECEIVED: 서버가 클라이언트로부터 SYN 패킷을 받고 SYN+ACK를 보낸 후, 클라이언트의 ACK를 기다리는 상태입니다.
    

3.  **[Client -> Server] ACK**
    -   클라이언트는 서버의 `SYN+ACK` 패킷을 받고, 서버의 시퀀스 번호에 1을 더한 값 `(server_isn + 1)`을 담은 `ACK` 패킷을 서버로 전송합니다.
    -   이 패킷을 받은 서버는 `ESTABLISHED` 상태로 전환됩니다.
    -   `ACK` 패킷을 보낸 클라이언트 역시 `ESTABLISHED` 상태로 전환되며, 이로써 연결이 완전히 성립되고 데이터 전송이 시작될 수 있습니다.
    > ESTABLISHED: 3-way Handshake가 완료되어 클라이언트와 서버 간에 데이터 전송이 가능한 상태입니다.

## 2. 연결 해제: 4-way Handshake

4-way Handshake는 설정된 연결을 안전하게 종료하기 위한 4단계 과정입니다. 한쪽이 연결을 끊더라도, 다른 쪽은 아직 보낼 데이터가 남아있을 수 있기 때문에(**Half-close**), 각 방향의 연결을 독립적으로 종료하는 복잡한 절차를 거칩니다.
> Half-close: 한쪽 방향의 데이터 전송은 종료되었지만, 다른 쪽 방향으로는 여전히 데이터 전송이 가능한 상태를 의미합니다.

### 과정
1.  **[Client -> Server] FIN (Finish)**
    -   클라이언트는 데이터 전송을 마쳤음을 알리기 위해 `FIN` 패킷을 서버로 보냅니다.
    -   클라이언트는 `FIN_WAIT_1` 상태로 전환됩니다.
    > FIN: 연결 종료를 요청하기 위해 사용되는 제어 패킷입니다.

    > FIN_WAIT_1: 클라이언트가 FIN 패킷을 보내고 서버의 ACK 응답을 기다리는 상태입니다.
    

2.  **[Server -> Client] ACK**
    -   서버는 클라이언트의 `FIN` 패킷을 받고, 일단 확인했다는 의미의 `ACK` 패킷을 보냅니다.
    -   이때 서버는 아직 보낼 데이터가 남아있을 수 있으므로, 자신의 연결은 바로 닫지 않고 `CLOSE_WAIT` 상태로 전환됩니다.
    -   `ACK`를 받은 클라이언트는 `FIN_WAIT_2` 상태가 되어 서버의 `FIN`을 기다립니다.
    > CLOSE_WAIT: 상대방으로부터 FIN을 받았지만, 아직 자신이 보낼 데이터가 남아있어 연결을 완전히 닫지 않고 기다리는 상태입니다.

3.  **[Server -> Client] FIN**
    -   서버가 자신의 모든 데이터 전송을 마치면, 연결을 종료하겠다는 `FIN` 패킷을 클라이언트로 보냅니다.
    -   서버는 `LAST_ACK` 상태로 전환되어 마지막 `ACK`를 기다립니다.
    > LAST_ACK: 서버가 FIN 패킷을 보내고 클라이언트로부터 마지막 ACK를 기다리는 상태입니다.

4.  **[Client -> Server] ACK**
    -   클라이언트는 서버의 `FIN` 패킷을 받고, 확인했다는 `ACK` 패킷을 보냅니다.
    -   클라이언트는 `TIME_WAIT` 상태로 전환되어, 네트워크에 남아있을 수 있는 잔여 패킷을 기다린 후 연결을 완전히 종료합니다.
    -   `ACK`를 받은 서버는 즉시 연결을 종료합니다.
    > TIME_WAIT: 4-way Handshake 과정에서 마지막 ACK를 보낸 후, 지연 패킷으로 인한 문제를 방지하고 모든 패킷이 정상적으로 처리되도록 일정 시간 동안 기다리는 상태입니다.

    > 실무적 영향: `TIME_WAIT` 상태의 소켓이 많아지면 서버의 포트 자원이 고갈될 수 있습니다. 이를 해결하기 위해 `SO_REUSEADDR` 소켓 옵션을 사용하여 커널이 이미 사용 중인 주소와 포트 쌍을 재사용하도록 허용할 수 있습니다.
    > `SO_REUSEADDR`: 소켓 옵션 중 하나로, 일반적으로 소켓이 닫힌 후 `TIME_WAIT` 상태에 있을 때 해당 포트를 즉시 재사용할 수 있도록 허용합니다. 서버 재시작 시 이전에 사용하던 포트를 빠르게 다시 바인딩할 수 있게 해줍니다.
    > 2MSL (2 Maximum Segment Lifetime): TCP 연결 종료 시 `TIME_WAIT` 상태에서 대기하는 시간으로, 네트워크 상에 남아있을 수 있는 지연 패킷이 모두 소멸될 수 있도록 충분한 시간을 제공합니다. MSL은 패킷이 네트워크에서 최대로 존재할 수 있는 시간을 의미하며, 2MSL은 왕복 시간을 고려한 값입니다.

이러한 Handshake 구조는 단순한 연결 이상의 의미를 가지며, 데이터의 순서 보장, 패킷 손실 방지, 흐름 제어 등 TCP의 핵심 기능을 가능하게 하는 기반이 됩니다.

## 3. RST (Reset) 패킷의 역할

`RST` 패킷은 비정상적인 연결 종료 시 사용됩니다. 예를 들어, 존재하지 않는 포트로 연결을 시도하거나, 이미 닫힌 연결에 데이터를 보낼 때 `RST` 패킷이 전송됩니다. `RST` 패킷을 받으면 해당 연결은 즉시 끊어지고 모든 상태 정보가 초기화됩니다. 이는 `FIN`을 통한 정상적인 연결 종료와 달리, 즉각적이고 강제적인 연결 해제를 의미합니다.

실무적 예시: 클라이언트가 `TIME_WAIT` 상태에서 서버에 재접속을 시도할 때, 서버는 이전 연결이 아직 완전히 종료되지 않았음을 감지하고 `RST` 패킷으로 응답하여 클라이언트에게 새로운 연결을 시도하도록 유도할 수 있습니다.

## 4. TCP 상태 머신 요약

TCP 연결의 주요 상태 변화는 다음과 같이 시각화할 수 있습니다:
-   **서버 측**: `CLOSED` → `LISTEN` → `SYN_RECEIVED` → `ESTABLISHED` → `CLOSE_WAIT` → `LAST_ACK` → `CLOSED`
-   **클라이언트 측**: `CLOSED` → `SYN_SENT` → `ESTABLISHED` → `FIN_WAIT_1` → `FIN_WAIT_2` → `TIME_WAIT` → `CLOSED`

## 5. TCP 연결 유지 전략: Keep-Alive
`Keep-Alive` 옵션은 TCP 연결이 일정 시간 동안 비활성 상태일 때, 연결이 유효한지 확인하기 위해 작은 패킷을 주기적으로 전송하는 메커니즘입니다. 이를 통해 불필요하게 끊어진 연결을 감지하고, 장시간 연결이 필요한 서비스(예: 채팅, 스트리밍, 게임)에서 연결을 유지하는 데 활용됩니다. `Keep-Alive`는 네트워크 자원을 효율적으로 사용하고, 클라이언트와 서버 간의 연결 상태를 최신으로 유지하는 데 도움을 줍니다.

### Keep-Alive vs Application-level Ping (실무적 비교)

-   **Keep-Alive**: 운영체제(OS) 수준에서 TCP 스택이 관리하는 기능입니다. 애플리케이션 계층에서는 투명하게 동작하며, 주로 연결 자체의 유효성을 확인하는 데 중점을 둡니다. 네트워크 장비(방화벽, NAT 등)에 의해 유휴 연결이 끊기는 것을 방지하는 데 효과적입니다.
-   **Application-level Ping**: 애플리케이션 개발자가 직접 구현하는 방식으로, 특정 애플리케이션 프로토콜 내에서 정의된 "ping" 메시지를 주고받아 연결의 활성 상태를 확인합니다. 이는 단순히 연결의 유효성뿐만 아니라, 애플리케이션 서버의 응답성이나 특정 서비스의 가용성까지 확인할 수 있다는 장점이 있습니다. 예를 들어, 온라인 게임에서는 자체적으로 일정 주기로 "ping" 메시지를 보내어 플레이어와 서버 간의 연결 상태 및 지연 시간을 모니터링하고, 이를 통해 게임 플레이 경험에 영향을 미치는 네트워크 문제를 감지하고 대응합니다.

또한, 웹소켓(WebSocket) 기반 서비스에서는 주기적으로 `ping` 프레임을 클라이언트에서 서버로, 또는 그 반대로 전송하고 `pong` 프레임으로 응답을 받음으로써 연결이 활성 상태인지 확인하고, 네트워크 장비나 운영체제에 의해 유휴 상태로 간주되어 끊어지는 것을 방지하여 연결을 유지하는 데 활용됩니다.
> **유휴 연결 (Idle Connection)**: 일정 시간 동안 데이터 송수신이 없어 비활성 상태가 된 TCP 연결을 의미합니다. 이러한 연결은 네트워크 장비(방화벽, NAT 등)에 의해 예고 없이 끊어질 수 있으며, 이를 방지하기 위한 전략이 필요합니다.

두 방식 모두 연결 유지에 기여하지만, `Keep-Alive`는 하위 계층에서 연결의 물리적 유효성을, `Application-level Ping`은 상위 계층에서 서비스의 논리적 유효성을 확인하는 데 더 적합합니다.