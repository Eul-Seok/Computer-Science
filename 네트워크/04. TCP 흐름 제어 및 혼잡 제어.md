# 04. TCP 흐름 제어 및 혼잡 제어

TCP는 신뢰성 있는 데이터 전송을 위해 <b>흐름 제어(Flow Control)</b>와 <b>혼잡 제어(Congestion Control)</b>라는 두 가지 중요한 메커니즘을 사용합니다. 이들은 송신자와 수신자, 그리고 네트워크 전체의 상태를 고려하여 데이터 전송량을 조절함으로써 안정적이고 효율적인 통신을 가능하게 합니다.

## 흐름 제어 vs 혼잡 제어 비교

두 개념은 데이터 전송량을 조절한다는 공통점이 있지만, 목적과 제어 방식에서 차이가 있습니다.

| 구분 | 흐름 제어 (Flow Control) | 혼잡 제어 (Congestion Control) |
|------|--------------------------|--------------------------------|
| 목적 | 수신자의 처리 능력 보호 | 네트워크 전체 혼잡 방지 |
| 기준 | 수신 윈도우(rwnd) | 혼잡 윈도우(cwnd) |
| 제어 단위 | 송신자 ↔ 수신자 | 송신자 ↔ 네트워크 |
| 구현 방식 | Sliding Window | Slow Start, AIMD, Fast Retransmit/Recovery |

## 흐름 제어와 혼잡 제어의 상호작용

TCP는 흐름 제어와 혼잡 제어를 동시에 사용하여 데이터 전송량을 조절합니다. 실제로 송신자가 한 번에 보낼 수 있는 데이터의 양(전송 윈도우)은 수신자의 버퍼 여유 공간(`rwnd`, 수신 윈도우)과 네트워크의 혼잡 상태를 나타내는 `cwnd`(혼잡 윈도우) 중 더 작은 값으로 결정됩니다.

> 혼잡 윈도우 (Congestion Window, cwnd): 송신자가 네트워크의 혼잡 상황을 예측하여 한 번에 보낼 수 있는 최대 데이터 양을 나타내는 값입니다. 네트워크 혼잡이 감지되면 cwnd가 줄어들고, 혼잡이 없으면 증가합니다.

**전송 윈도우 = min(rwnd, cwnd)**

이는 수신자의 처리 능력을 보호하는 동시에 네트워크 전체의 혼잡을 방지하기 위한 TCP의 핵심적인 동작 방식입니다. 즉, 아무리 수신자가 많은 데이터를 받을 준비가 되어 있어도(rwnd가 커도), 네트워크가 혼잡하면(cwnd가 작으면) 송신자는 전송 속도를 줄여야 합니다. 반대로 네트워크가 여유 있어도(cwnd가 커도), 수신자가 데이터를 처리할 여력이 없으면(rwnd가 작으면) 송신자는 수신자의 능력에 맞춰 전송 속도를 조절합니다.

## 1. 흐름 제어 (Flow Control)

**흐름 제어**는 송신자가 수신자의 처리 능력을 초과하지 않도록 데이터 전송량을 조절하는 메커니즘입니다. 수신자가 데이터를 처리하는 속도보다 송신자가 데이터를 보내는 속도가 빠르면, 수신자의 버퍼(Buffer)가 오버플로우되어 데이터 손실이 발생할 수 있습니다.

### 동작 방식: Sliding Window (슬라이딩 윈도우)
TCP는 **Sliding Window** 방식을 사용하여 흐름 제어를 구현합니다. 수신자는 자신이 받을 수 있는 데이터의 양(수신 윈도우 크기)을 송신자에게 알려주고, 송신자는 이 윈도우 크기 내에서만 데이터를 전송합니다.

-   **수신 윈도우 (Receive Window, `rwnd`)**: 수신자가 현재 받을 수 있는 버퍼의 여유 공간 크기를 나타냅니다. 수신자는 `ACK` 패킷에 `rwnd` 값을 포함하여 송신자에게 보냅니다.

**실무적 예시**: 대용량 파일을 다운로드할 때, 수신 측 컴퓨터의 처리 속도가 느리거나 버퍼가 거의 꽉 차면, 수신 윈도우(`rwnd`) 크기를 줄여 송신자에게 알립니다. 송신자는 이 `rwnd` 값에 맞춰 전송 속도를 자동으로 줄여, 수신 측의 버퍼 오버플로우를 방지하고 데이터 손실 없이 안정적으로 파일을 받을 수 있도록 합니다.

## 2. 혼잡 제어 (Congestion Control)

**혼잡 제어**는 네트워크의 혼잡(Congestion)을 감지하고, 데이터 전송 속도를 동적으로 조절하여 네트워크 전체의 안정성과 효율성을 유지하는 핵심 메커니즘입니다. 송신 측은 자신이 보낸 데이터가 네트워크를 혼잡하게 만들지 않도록 스스로 전송량을 제어합니다.

**실무적 예시**: 온라인 동영상 스트리밍 서비스에서 사용자가 많은 시간대나 특정 구간의 네트워크 트래픽이 증가하여 혼잡이 발생하면, 스트리밍 서버는 이를 감지하고 자동으로 동영상 화질을 낮춰 전송합니다. 이는 네트워크 혼잡을 완화하고, 사용자가 끊김 없이 영상을 시청할 수 있도록 전송량을 조절하는 혼잡 제어의 대표적인 사례입니다.

### 혼잡 제어의 4가지 핵심 알고리즘

TCP 혼잡 제어는 주로 4가지 알고리즘의 조합으로 동작합니다.

### 1. Slow Start (느린 시작)
-   **동작**: 연결 초기 단계에서 `cwnd`를 1 <b>MSS(Maximum Segment Size)</b>로 설정하고, `ACK`를 받을 때마다 `cwnd`를 1 MSS씩 증가시킵니다. 결과적으로 매 <b>RTT(Round Trip Time)</b>마다 `cwnd`가 2배씩 지수적으로 증가하게 됩니다. (`1 -> 2 -> 4 -> 8...`)
-   **목적**: 네트워크의 수용 능력을 빠르게 탐색하여 초기 전송 속도를 확보하는 것입니다.
-   **종료 조건**: `cwnd`가 미리 설정된 <b>임계값(`ssthresh`, Slow Start Threshold)</b>에 도달하거나, 패킷 손실이 감지되면 Slow Start 단계가 종료되고 '혼잡 회피' 단계로 전환됩니다.
> ssthresh (Slow Start Threshold): Slow Start 단계에서 Congestion Avoidance 단계로 전환되는 임계값입니다. 보통 네트워크 혼잡이 발생했을 때 cwnd의 절반 값으로 설정됩니다.

### 2. Congestion Avoidance (혼잡 회피)
-   **동작**: Slow Start 이후, 네트워크의 혼잡을 방지하기 위해 `cwnd`를 조심스럽게 증가시키는 단계입니다. `ACK`를 받을 때마다 `cwnd`를 `1/cwnd` 만큼씩 증가시켜, 결과적으로 한 RTT마다 `cwnd`가 1 MSS씩 선형적으로 증가합니다.
-   **목적**: `cwnd`의 지수적인 증가로 인한 급격한 네트워크 부하를 막고, 안정적으로 최대 전송량을 찾아가기 위함입니다.
-   **알고리즘**: 이처럼 `cwnd`를 조심스럽게 늘리고(Additive Increase), 혼잡이 발생하면 `cwnd`를 대폭 줄이는(Multiplicative Decrease) 방식을 **AIMD(Additive Increase / Multiplicative Decrease)** 라고 부릅니다.

### 3. Fast Retransmit (빠른 재전송)
-   **동작**: 수신 측은 중간에 패킷이 손실된 것을 감지하면, 순서에 맞게 도착한 마지막 패킷에 대한 `ACK`를 반복해서 보냅니다. 송신 측이 이 중복된 `ACK`를 3번 수신하면, 타임아웃(Timeout)이 발생하기 전에 "패킷이 손실되었다"고 판단하고 즉시 해당 패킷을 재전송합니다.
-   **목적**: 타임아웃까지 기다리는 불필요한 지연을 줄이고, 손실된 패킷을 빠르게 복구하여 전송 효율을 높입니다.

### 4. Fast Recovery (빠른 회복)
-   **동작**: '빠른 재전송'이 발생한 후, TCP는 이를 네트워크 혼잡의 신호로 받아들입니다. 이때 `ssthresh` 값을 현재 `cwnd`의 절반으로 줄이고, `cwnd`도 새로운 `ssthresh` 값으로 설정합니다. 그 후, '혼잡 회피' 단계로 바로 진입하여 `cwnd`를 선형적으로 증가시킵니다.
-   **목적**: Slow Start 단계(cwnd=1)부터 다시 시작하는 대신, 네트워크 대역폭을 어느 정도 유지한 상태에서 안정적으로 회복하여 전체적인 전송 성능 저하를 최소화합니다.

## 게임 개발 실무 (C++) 관점

게임 개발에서 TCP의 흐름 제어와 혼잡 제어는 대부분 운영체제와 네트워크 라이브러리(예: `boost::asio`, `winsock`)에 의해 자동으로 처리됩니다. 개발자가 직접 이 메커니즘을 구현할 필요는 거의 없습니다.

-   **TCP 기반 게임**: 로그인, 채팅, 아이템 구매 등 신뢰성이 중요한 통신에는 TCP를 사용하며, 운영체제가 제공하는 흐름/혼잡 제어 덕분에 개발자는 데이터 전송의 신뢰성에 크게 신경 쓰지 않아도 됩니다. 다만, 네트워크 환경이 좋지 않을 경우 TCP의 재전송 및 윈도우 조절로 인해 게임 지연이 발생할 수 있음을 이해해야 합니다.
-   **UDP 기반 게임**: 실시간 액션 게임 등 낮은 지연이 중요한 경우 UDP를 사용합니다. UDP는 흐름 제어나 혼잡 제어 기능이 없으므로, 개발자가 직접 애플리케이션 레벨에서 이와 유사한 메커니즘을 구현해야 할 때가 있습니다.
    -   **흐름 제어**: 수신 측의 버퍼 상태를 송신 측에 주기적으로 알려주어 송신량을 조절하는 로직을 구현할 수 있습니다.
    -   **혼잡 제어**: 패킷 손실률이나 RTT 변화를 감지하여 전송 속도를 동적으로 조절하는 알고리즘(예: 게임에 특화된 AIMD 변형)을 구현하여 네트워크 혼잡에 대응할 수 있습니다.
    -   이는 매우 복잡하고 고도의 전문성을 요구하는 작업입니다.

C++에서는 `winsock`이나 `boost::asio` 같은 소켓 API를 사용하여 TCP/UDP 통신을 구현하며, 이들 라이브러리는 TCP의 흐름/혼잡 제어를 추상화하여 제공합니다. 개발자는 주로 `send()`와 `recv()` 함수의 블로킹/논블로킹 특성, 버퍼 관리 등에 집중하게 됩니다.

## 6. 현대 TCP 혼잡 제어 알고리즘 (CUBIC, BBR)

TCP 혼잡 제어 알고리즘은 네트워크 환경의 변화에 맞춰 지속적으로 발전해왔습니다. 전통적인 TCP Reno/Tahoe 알고리즘 외에도, 현대에는 다양한 변형 알고리즘들이 사용되고 있습니다.

-   **CUBIC**: 현재 리눅스 운영체제의 기본 TCP 혼잡 제어 알고리즘입니다. 주로 고대역폭-고지연(Long Fat Network, LFN) 환경에서 높은 성능을 발휘하도록 설계되었습니다. `cwnd`를 RTT와 무관하게 큐브 함수(cubic function)를 사용하여 증가시키며, 네트워크 자원을 보다 공격적으로 활용하면서도 안정성을 유지하려 합니다.
> LFN (Long Fat Network): 대역폭은 높지만 RTT(왕복 시간)가 긴 네트워크 환경을 의미합니다. 위성 통신이나 대륙 간 해저 케이블 연결 등이 대표적인 예시입니다.
-   **BBR (Bottleneck Bandwidth and RTT)**: 구글에서 개발한 혼잡 제어 알고리즘으로, 기존의 손실 기반(loss-based) 혼잡 제어와 달리 대역폭(Bandwidth)과 RTT를 직접 측정하여 네트워크의 실제 용량을 추정하고 `cwnd`를 조절합니다. 이를 통해 패킷 손실이 발생하지 않더라도 네트워크 혼잡을 예측하고, 더 높은 처리량과 낮은 지연 시간을 제공하는 것을 목표로 합니다. 특히 손실이 잦은 무선 네트워크 환경이나 대규모 데이터 전송에 유리합니다.

이러한 현대 알고리즘들은 네트워크의 특성을 더 잘 이해하고, 기존 알고리즘의 한계를 극복하여 더 효율적이고 안정적인 데이터 전송을 가능하게 합니다.