# 07. TLS Handshake 과정

**TLS Handshake**는 클라이언트와 서버가 안전한 통신을 시작하기 위해 서로를 인증하고, 암호화에 사용할 비밀 키를 안전하게 교환하는 일련의 과정입니다. 이 과정은 HTTP 통신을 HTTPS로 전환할 때, 또는 다른 프로토콜에서 보안 채널을 구축할 때 사용됩니다.

## TLS Handshake의 주요 단계

TLS Handshake는 여러 메시지를 주고받으며 진행되지만, 핵심적인 단계는 다음과 같습니다.

1.  **[Client -> Server] Client Hello**
    -   클라이언트는 서버에 연결을 요청하면서 **클라이언트 Hello** 메시지를 보냅니다.
    -   이 메시지에는 클라이언트가 지원하는 TLS 버전, 암호화 스위트(Cipher Suite) 목록, 압축 방식, 그리고 무작위로 생성된 데이터(Client Random) 등이 포함됩니다.
    > 암호화 스위트: TLS 통신에 사용될 키 교환, 인증, 암호화, 메시지 인증 코드(MAC) 알고리즘들의 조합.

2.  **[Server -> Client] Server Hello & Certificate**
    -   서버는 클라이언트 Hello 메시지를 받고, 자신이 지원하는 TLS 버전과 암호화 스위트를 선택하여 **서버 Hello** 메시지를 보냅니다.
    -   이와 함께 서버는 자신의 <b>인증서(Certificate)</b>를 클라이언트에게 전송합니다. 인증서에는 서버의 <b>공개키(Public Key)</b>가 포함되어 있습니다.
    -   서버는 또한 무작위로 생성된 데이터(Server Random)를 클라이언트에게 보냅니다.
    > 공개키: 암호화된 데이터를 복호화하거나 디지털 서명을 검증하는 데 사용되는 키로, 누구나 알 수 있도록 공개됩니다.

3.  **[Client] Certificate Verification & Pre-Master Secret**
    -   클라이언트는 서버로부터 받은 인증서의 유효성을 검증합니다. (인증 기관 확인, 만료일 확인 등)
    -   검증이 완료되면, 클라이언트는 통신에 사용할 <b>대칭키(Symmetric Key)</b>를 생성하기 위한 **Pre-Master Secret**이라는 무작위 값을 생성합니다.
    -   이 Pre-Master Secret을 서버의 **공개키**로 암호화하여 서버에 전송합니다.
    > 대칭키: 암호화와 복호화에 동일한 키를 사용하는 방식. 공개키 방식보다 연산 속도가 빠릅니다.

4.  **[Server] Decryption & Master Secret Generation**
    -   **키 교환 방식**:
        -   **RSA 기반**: 클라이언트가 생성한 Pre-Master Secret을 서버의 공개키로 암호화하여 전송하면, 서버는 자신의 개인키로 이를 복호화하여 Pre-Master Secret을 얻습니다. (과거 방식)
        -   **Diffie-Hellman (ECDHE) 기반**: 클라이언트와 서버가 각자의 개인키와 상대방의 공개키를 사용하여 Pre-Master Secret을 안전하게 생성합니다. 이 방식은 <b>Perfect Forward Secrecy (PFS)</b>를 제공하여, 설령 서버의 개인키가 나중에 유출되더라도 과거 통신 내용을 복호화할 수 없도록 합니다. (현대적인 권장 방식)
    -   서버는 자신의 <b>개인키(Private Key)</b>로 클라이언트가 암호화하여 보낸 Pre-Master Secret을 복호화합니다.
    -   클라이언트와 서버는 각각 Client Random, Server Random, Pre-Master Secret을 사용하여 동일한 **Master Secret**을 생성합니다. 이 Master Secret을 기반으로 실제 데이터 암호화에 사용될 <b>세션 키(Session Key)<b>를 생성합니다.
    > 개인키: 공개키로 암호화된 데이터를 복호화하거나 디지털 서명을 생성하는 데 사용되는 키로, 소유자만 비밀리에 보관합니다.

5.  **[Client & Server] Change Cipher Spec & Finished**
    -   클라이언트와 서버는 이제부터 생성된 세션 키를 사용하여 암호화된 통신을 시작하겠다는 메시지(Change Cipher Spec)와, 지금까지의 Handshake 과정이 성공적으로 완료되었음을 알리는 메시지(Finished)를 암호화하여 주고받습니다。
    -   이후부터는 모든 애플리케이션 데이터가 세션 키로 전송됩니다.


## 게임 개발 실무 (C++) 관점

게임 개발에서도 TLS Handshake는 클라이언트와 서버 간의 보안 채널을 구축하는 데 매우 중요합니다. 특히 사용자 인증, 결제, 민감한 게임 데이터 전송 시 필수적입니다.

-   **보안 채널 구축**: 게임 클라이언트가 게임 서버에 접속할 때, 또는 웹 기반 API(HTTPS)를 호출할 때 TLS Handshake를 통해 안전한 통신 경로를 확보합니다. 이를 통해 중간자 공격(Man-in-the-Middle Attack)이나 데이터 스니핑(Sniffing)을 방지할 수 있습니다。
  > 중간자 공격: 통신하는 두 당사자 사이에 끼어들어 메시지를 가로채거나 위변조하는 공격 방식.

  > 데이터 스니핑: 네트워크 상의 데이터를 몰래 엿듣거나 가로채는 행위.

-   **C++에서의 구현**:
    -   `OpenSSL` 라이브러리는 C++에서 TLS/SSL 통신을 구현하는 데 가장 널리 사용됩니다. `OpenSSL` API를 직접 사용하여 TLS Handshake 과정을 제어하고, 인증서 관리, 키 교환 등을 구현할 수 있습니다. 이는 복잡하지만 세밀한 제어가 가능합니다.
    -   `boost::asio`와 같은 네트워크 라이브러리는 `OpenSSL`과의 통합을 통해 TLS/SSL 소켓을 쉽게 사용할 수 있도록 추상화된 인터페이스를 제공합니다. 개발자는 `ssl::stream` 객체를 사용하여 Handshake를 시작하고 데이터를 주고받을 수 있습니다。
    
    > OpenSSL: TLS/SSL 프로토콜을 구현한 오픈 소스 암호화 라이브러리.

    > boost::asio: C++에서 네트워크 및 저수준 I/O 작업을 위한 크로스 플랫폼 라이브러리.
-   **성능 최적화**:
    -   TLS Handshake는 공개키 암호화 연산 때문에 비교적 많은 CPU 자원과 시간을 소모합니다. 따라서 게임에서는 **세션 재개(Session Resumption)** 기능을 활용하여 이미 한 번 Handshake를 완료한 클라이언트가 다시 접속할 때 Handshake 과정을 단축시켜 지연을 줄이고 서버 부하를 경감시킵니다.
    -   게임 서버는 대량의 동시 접속을 처리해야 하므로, TLS Handshake의 성능 최적화는 매우 중요한 고려 사항입니다. 하드웨어 가속기나 효율적인 암호화 알고리즘 선택도 중요합니다.
    > OpenSSL: TLS/SSL 프로토콜을 구현한 오픈 소스 암호화 라이브러리.

    > 세션 재개: 이전에 연결했던 클라이언트와 서버가 TLS Handshake 과정을 단축하여 빠르게 재연결하는 기술.

TLS Handshake 과정을 이해하는 것은 게임의 보안 아키텍처를 설계하고, 네트워크 문제를 진단하며, 성능을 최적화하는 데 큰 도움이 됩니다.