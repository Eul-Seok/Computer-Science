# 09. REST API

<b>REST(Representational State Transfer)</b>는 웹 서비스 디자인 아키텍처 스타일 중 하나로, 분산 하이퍼미디어 시스템을 위한 아키텍처 원칙 집합입니다. RESTful API는 이 REST 원칙을 따르는 API를 의미하며, 웹의 기존 기술(HTTP, URI)을 최대한 활용하여 확장 가능하고 유연한 웹 서비스를 구축하는 데 사용됩니다.
> **분산 하이퍼미디어 시스템**: 여러 서버에 분산된 하이퍼미디어(링크로 다른 미디어에 접근)를 하나의 시스템처럼 상호작용하게 하는 환경

## 1. REST의 6가지 아키텍처 원칙

RESTful API는 다음 6가지 원칙을 준수해야 합니다.

1.  **클라이언트-서버 (Client-Server)**: 클라이언트와 서버의 역할이 명확히 분리되어야 합니다. 클라이언트는 사용자 인터페이스와 사용자 상태를 관리하고, 서버는 리소스와 데이터 처리를 담당합니다.
2.  **무상태 (Stateless)**: 서버는 클라이언트의 요청 간에 어떤 클라이언트 상태도 저장하지 않습니다. 각 요청은 필요한 모든 정보를 포함해야 합니다.
3.  **캐시 가능 (Cacheable)**: 클라이언트가 서버 응답을 캐시할 수 있도록 하여, 서버의 부하를 줄이고 응답 속도를 향상시킬 수 있어야 합니다.
4.  **계층화된 시스템 (Layered System)**: 클라이언트는 서버와 직접 통신하는지, 중간 서버(프록시, 로드밸런서 등)와 통신하는지 알 수 없어야 합니다.
    > **프록시(Proxy)**: 클라이언트를 대신해 다른 서버와 통신하는 중개 서버

    > **로드밸런서(Load Balancer)**: 여러 서버에 작업(부하)을 나누어 처리 성능과 안정성을 높이는 기술

5.  **균일한 인터페이스 (Uniform Interface)**: REST의 핵심 원칙으로, 시스템 전체에 걸쳐 일관된 인터페이스를 제공해야 합니다. 이는 다음 네 가지 하위 원칙으로 구성됩니다.
    -   **자원 식별 (Identification of resources)**: 모든 자원은 <b>URI(Uniform Resource Identifier)</b>로 식별됩니다.
    -   **메시지를 통한 자원 조작 (Manipulation of resources through representations)**: 클라이언트가 자원의 표현(Representation)을 통해 자원을 조작합니다.
    -   **자기 서술적 메시지 (Self-descriptive messages)**: 메시지 자체에 메시지를 해석하는 데 필요한 모든 정보가 포함되어야 합니다.
    -   **하이퍼미디어 (Hypermedia as the Engine of Application State, HATEOAS)**: 애플리케이션의 상태는 하이퍼링크를 통해 전이되어야 합니다. (선택적)
6.  **코드 온 디맨드 (Code-On-Demand)**: 서버가 클라이언트에 실행 가능한 코드를 전송하여 클라이언트 기능을 확장할 수 있습니다. (선택적)

## 2. REST API의 구성 요소

REST API는 주로 다음 세 가지 요소로 구성됩니다.

1.  **자원 (Resource)**: API가 제공하는 핵심 대상입니다. 예를 들어, 사용자 정보, 게시물, 아이템 등이 자원이 될 수 있습니다.
2.  **URI (Uniform Resource Identifier)**: 자원을 식별하는 고유한 주소입니다. 자원의 명사를 사용하여 표현하며, 행위(동사)는 포함하지 않습니다. (예: `/users`, `/products/123`)
3.  **HTTP 메서드 (HTTP Methods)**: 자원에 대한 행위(CRUD: Create, Read, Update, Delete)를 정의합니다.
    -   **GET**: 자원 조회 (Read). 서버의 데이터를 변경하지 않습니다. <b>멱등성(Idempotent)</b>을 가집니다.
        > **멱등성**: 여러 번 수행해도 결과가 같은 성질
    -   **POST**: 자원 생성 (Create). 서버에 새로운 자원을 생성합니다.
    -   **PUT**: 자원 전체 업데이트 (Update). 자원 전체를 덮어씁니다. **멱등성**을 가집니다.
    -   **DELETE**: 자원 삭제 (Delete). 자원을 삭제합니다. **멱등성**을 가집니다.
    -   **PATCH**: 자원 부분 업데이트 (Update). 자원의 일부만 업데이트합니다.

## 3. REST API의 장단점

### 장점
-   **단순성 및 범용성**: HTTP 표준을 따르므로 이해하기 쉽고, 다양한 클라이언트(웹, 모바일, 데스크톱)에서 사용 가능합니다.
-   **확장성**: 무상태성 덕분에 서버를 쉽게 확장할 수 있습니다.
-   **캐싱**: HTTP 캐싱 기능을 활용하여 성능을 향상시킬 수 있습니다.

### 단점
-   **무상태성**: 클라이언트의 상태를 서버가 유지하지 않으므로, 매 요청마다 모든 정보를 포함해야 합니다. 이는 요청의 크기를 증가시킬 수 있습니다.
-   **오버페칭/언더페칭**: 필요한 데이터보다 더 많거나 적은 데이터를 가져올 수 있어, 추가적인 요청이나 불필요한 데이터 전송이 발생할 수 있습니다. (GraphQL 등으로 보완 가능)
    > **GraphQL**: 클라이언트가 필요한 데이터만 정확하게 요청할 수 있도록 하는 데이터 질의 언어

## 4. 보안 측면

REST API는 본질적으로 HTTP 프로토콜을 사용하므로, 보안을 강화하기 위한 추가적인 고려가 필요합니다.
-   **HTTPS 사용**: 모든 REST API 통신은 반드시 HTTPS를 통해 이루어져야 합니다. 이를 통해 데이터 암호화, 무결성 보장, 서버 인증을 확보하여 중간자 공격(Man-in-the-Middle Attack)과 데이터 스니핑(Sniffing)을 방지합니다.
    > **HTTPS (Hypertext Transfer Protocol Secure)**: HTTP의 보안이 강화된 버전으로, 통신을 암호화하여 보호합니다.

    > **중간자 공격**: 통신 두 주체 사이에 끼어들어 데이터를 엿보거나 조작하는 공격

    > **데이터 스니핑**: 네트워크를 통해 전송되는 데이터를 도청하는 행위

-   **인증 (Authentication)**: 클라이언트의 신원을 확인하는 과정입니다.
    -   **토큰 기반 인증 (Token-based Authentication)**: JWT(JSON Web Token)와 같은 토큰을 사용하여 클라이언트의 인증 상태를 유지합니다. 서버는 상태를 저장하지 않으므로 REST의 무상태 원칙을 준수합니다.
        > **JWT(JSON Web Token)**: 웹에서 인증 정보를 안전하게 전송하기 위한 JSON 기반의 개방형 표준
    -   **OAuth 2.0**: 서드파티 애플리케이션이 사용자 대신 특정 리소스에 접근할 수 있는 권한을 부여하는 표준 프레임워크입니다. (예: 구글, 카카오 로그인 연동)
-   **인가 (Authorization)**: 인증된 클라이언트가 특정 리소스에 접근하거나 특정 작업을 수행할 권한이 있는지 확인하는 과정입니다. 역할 기반 접근 제어(RBAC)나 속성 기반 접근 제어(ABAC) 등을 통해 구현됩니다.
    > **역할 기반 접근 제어(RBAC)**: 사용자에게 할당된 역할에 따라 리소스 접근 권한을 부여하는 방식

    > **속성 기반 접근 제어(ABAC)**: 사용자의 속성(예: 부서, 직책)에 따라 접근 권한을 부여하는 방식

## 5. 성능 최적화

REST API는 대규모 서비스에서 효율적인 데이터 전송과 서버 부하 관리를 위해 다양한 성능 최적화 기법을 적용할 수 있습니다.
-   **페이지네이션 (Pagination)**: 대량의 데이터를 한 번에 전송하는 대신, 특정 단위(페이지)로 나누어 전송합니다. (예: `/users?page=1&size=10`)
-   **필드 선택 (Field Selection / Projection)**: 클라이언트가 필요한 필드만 선택하여 요청할 수 있도록 합니다. 불필요한 데이터 전송을 줄여 네트워크 대역폭과 처리 시간을 절약합니다. (예: `/users?fields=id,name,email`)
-   **캐싱 (Caching)**: HTTP의 캐싱 메커니즘(Cache-Control, ETag 등)을 적극 활용하여 동일한 요청에 대한 서버 응답을 줄입니다.
    > **Cache-Control**: 캐시의 동작을 제어하는 HTTP 헤더 필드

    > **ETag**: 특정 버전의 리소스를 식별하는 식별자로, 캐시된 리소스가 변경되었는지 확인하는 데 사용됨

-   **Rate Limiting**: 클라이언트가 일정 시간 동안 보낼 수 있는 요청의 수를 제한하여 서버 과부하를 방지하고 서비스 안정성을 유지합니다。
-   **압축 (Compression)**: Gzip 등 데이터 압축을 통해 전송되는 데이터의 크기를 줄여 네트워크 지연을 감소시킵니다。
    > **Gzip**: 데이터를 압축하여 전송 크기를 줄이는 데 널리 사용되는 압축 형식

## 게임 개발 실무 (C++) 관점

게임 개발에서 REST API는 주로 게임의 비실시간적인 기능이나 웹 기반 서비스 연동에 활용됩니다.

-   **게임 클라이언트-서버 통신**:
    -   **사용자 인증 및 계정 관리**: 로그인, 회원가입, 비밀번호 변경, 사용자 프로필 조회 등은 REST API를 통해 안전하게 처리됩니다.
    -   **리더보드 및 랭킹 시스템**: 게임 내 랭킹 정보를 조회하거나 업데이트하는 데 REST API가 사용됩니다.
    -   **상점 및 인앱 구매**: 아이템 목록 조회, 구매 요청, 결제 처리 결과 확인 등에 REST API가 활용됩니다.
    -   **공지사항 및 이벤트**: 게임 내 공지사항, 이벤트 정보 등을 클라이언트가 서버로부터 받아오는 데 사용됩니다.
-   **REST vs. 실시간 통신**:
    -   REST API는 HTTP 기반이므로, 실시간성이 중요한 게임 플레이 데이터(캐릭터 위치, 공격 판정 등) 전송에는 적합하지 않습니다. 이러한 데이터는 주로 UDP나 WebSocket과 같은 프로토콜을 사용합니다.
        > **UDP (User Datagram Protocol)**: 데이터를 빠르게 전송하는 데 중점을 둔 비연결형 프로토콜로, 신뢰성보다는 속도가 중요할 때 사용됩니다.

        > **WebSocket**: 클라이언트와 서버 간의 양방향 통신을 가능하게 하는 프로토콜로, 실시간 상호작용에 적합합니다.
        
    -   REST API는 주로 **비실시간적이고 요청-응답 패턴이 명확한** 기능에 사용되며, 게임의 핵심 플레이 로직과는 분리하여 사용되는 경우가 많습니다.
-   **C++에서의 REST API 호출**:
    -   C++ 환경에서 REST API를 호출하는 가장 일반적인 방법은 `cURL` 라이브러리를 사용하는 것입니다. `cURL`은 HTTP/HTTPS 요청을 보내고 응답을 처리하는 강력한 기능을 제공합니다.
        > **cURL**: 다양한 프로토콜을 이용해 데이터를 전송하기 위한 라이브러리 및 명령줄 도구입니다.
    -   `cpprestsdk` (Casablanca)와 같은 라이브러리도 RESTful API 클라이언트 및 서버를 구축하는 데 사용될 수 있습니다.
    -   게임 엔진(Unreal Engine)은 자체적으로 HTTP/HTTPS 통신 모듈을 제공하며, 이를 통해 REST API를 쉽게 호출할 수 있습니다. 예를 들어, `FHttpModule`을 사용하여 `FHttpRequest`를 생성하고 `FHttpResponse`를 처리하는 방식입니다.

REST API는 게임의 백엔드 시스템과 클라이언트 간의 유연하고 확장 가능한 인터페이스를 제공하여, 게임 서비스의 다양한 기능을 구현하는 데 중요한 역할을 합니다.