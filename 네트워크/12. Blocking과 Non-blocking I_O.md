# 13. Blocking과 Non-blocking I/O

**Blocking I/O**와 **Non-blocking I/O**는 입출력(I/O) 작업이 수행될 때 **프로세스**의 동작 방식을 설명하는 개념입니다.
> - **프로세스(Process)**: 운영체제에서 실행 중인 프로그램의 인스턴스. 자신만의 메모리 공간, 코드, 데이터를 가집니다.

특히 네트워크 통신과 같이 외부 장치와의 상호작용이 많은 환경에서 시스템의 성능과 반응성에 큰 영향을 미칩니다.

## 1. Blocking I/O (블로킹 I/O)

**Blocking I/O**는 입출력 함수(예: `read()`, `write()`, `accept()`)가 호출되었을 때, 해당 입출력 작업이 완료될 때까지 호출한 **프로세스**의 실행 흐름이 멈추고 대기하는 방식입니다.

### 주요 특징
-   **단순한 구현**: 코드를 작성하기 쉽고 이해하기 직관적입니다.
-   **자원 낭비**: 입출력 작업이 진행되는 동안 프로세스가 아무것도 하지 않고 대기하므로, CPU 자원이 낭비될 수 있습니다.
-   **확장성 문제**: 하나의 프로세스/스레드가 하나의 클라이언트 요청을 처리하는 모델에서는 동시 접속자 수가 늘어날수록 성능이 급격히 저하됩니다.

## 2. Non-blocking I/O (논블로킹 I/O)

**Non-blocking I/O**는 입출력 함수가 호출되었을 때, 해당 입출력 작업이 즉시 완료되지 않더라도 호출한 프로세스에게 제어권을 즉시 반환하는 방식입니다. 프로세스는 제어권을 돌려받아 다른 작업을 계속 수행할 수 있습니다.

### 주요 특징
-   **높은 효율성**: 입출력 대기 시간 동안 다른 작업을 수행할 수 있으므로 CPU 자원을 효율적으로 활용합니다.
-   **복잡한 구현**: 입출력 작업의 완료 여부를 주기적으로 확인하거나(Polling), 완료 시점을 통보받는 메커니즘(이벤트 기반)이 필요하여 구현이 복잡해집니다.
-   **확장성**: 하나의 프로세스/스레드가 여러 클라이언트의 I/O를 동시에 처리할 수 있어 높은 동시 접속자 수를 지원하는 데 유리합니다.

## 3. I/O 모델 비교

| 구분 | Blocking I/O | Non-blocking I/O (Polling) | 이벤트 기반 I/O (Event Driven) |
| :--- | :--- | :--- | :--- |
| **CPU 활용률** | 낮음 (대기 시간 동안 낭비) | 매우 높음 (지속적인 확인으로 낭비) | 최적화 (이벤트 발생 시에만 사용) |
| **구현 난이도** | 쉬움 | 중간 | 어려움 |
| **확장성** | 낮음 | 중간 | 높음 |
| **응답 속도** | 느림 (하나의 작업이 전체를 막음) | 빠름 (대기 없음) | 매우 빠름 (대기/폴링 없음) |

## 4. 이벤트 기반 I/O 모델

Non-blocking I/O를 효율적으로 사용하기 위해 **이벤트 기반 I/O** 모델이 등장했습니다. 이는 운영체제가 여러 I/O 작업의 상태 변화(이벤트)를 감지하고, 준비된 I/O 작업이 있을 때 애플리케이션에 통보해주는 방식입니다.

### 주요 시스템 콜
-   **`select()` / `poll()`**:
    -   가장 오래된 이벤트 기반 I/O 모델입니다. 여러 파일 디스크립터(소켓)를 감시하다가 I/O 준비가 된 디스크립터가 있으면 알려줍니다.
    > - **파일 디스크립터(File Descriptor)**: 운영체제가 파일이나 소켓 등 I/O 객체를 식별하기 위해 부여하는 고유한 정수 값.
    -   단점: 감시할 디스크립터 수가 많아질수록 성능이 저하되고, 매번 모든 디스크립터를 순회해야 하는 오버헤드가 있습니다.
    > - **오버헤드(Overhead)**: 어떤 작업을 처리하기 위해 추가적으로 소요되는 시간이나 자원.

-   **`epoll()` (Linux)**:
    -   `select()`/`poll()`의 단점을 개선한 리눅스 전용 고성능 I/O 모델입니다.
    -   **특징**: 감시할 디스크립터 수가 많아져도 성능 저하가 적고, 이벤트가 발생한 디스크립터만 통보받으므로 효율적입니다.

-   **IOCP (Input/Output Completion Port) (Windows)**:
    -   윈도우즈 전용 고성능 I/O 모델입니다.
    -   **특징**: 비동기 I/O 작업이 완료되면 운영체제가 완료된 작업의 결과를 스레드 풀에 있는 워커 스레드에 전달합니다. 스레드 풀을 효율적으로 관리하여 높은 동시성을 제공합니다.
    > - **스레드 풀(Thread Pool)**: 미리 여러 개의 스레드를 생성해두고, 필요할 때마다 가져다 쓴 후 다시 반납하는 방식. 스레드를 생성하고 파괴하는 비용을 줄일 수 있습니다.

## 5. 게임 개발 실무 (C++) 관점

게임 서버는 수많은 클라이언트의 동시 접속을 처리해야 하므로, I/O 모델 선택이 서버의 성능과 확장성에 결정적인 영향을 미칩니다.

-   **게임 서버의 I/O 모델**:
    -   **시나리오**: 수만 명이 동시 접속하는 MMORPG 서버를 가정해봅시다. 만약 블로킹 I/O를 사용한다면, 플레이어 한 명당 하나의 스레드를 할당해야 하므로 수만 개의 스레드가 필요해져 메모리 및 컨텍스트 스위칭 비용으로 서버가 마비될 것입니다.
    -   **해결**: <b>Non-blocking I/O와 `epoll`</b>을 사용하면, 단 몇 개의 스레드만으로 전체 소켓을 관리할 수 있습니다. `epoll`이 데이터가 도착한 소켓만 알려주므로, 스레드는 실제로 이동하거나 스킬을 사용한 플레이어의 요청만 처리하고 나머지 수많은 유휴 플레이어에게는 자원을 전혀 사용하지 않아 높은 효율을 달성합니다.
    -   C++에서는 `epoll`, `IOCP` 시스템 콜을 직접 사용하거나, 이를 추상화한 `boost::asio` 같은 라이브러리를 활용합니다.
    > - **추상화(Abstraction)**: 복잡한 내부 구현을 숨기고, 사용자에게는 단순하고 일관된 인터페이스만 제공하는 것. `boost::asio`는 윈도우(IOCP)와 리눅스(epoll)의 차이를 숨겨줍니다.

-   **게임 클라이언트**:
    -   **시나리오**: 게임 클라이언트가 다음 스테이지의 방대한 맵 데이터를 로딩한다고 가정해봅시다. 만약 메인 스레드에서 블로킹 방식으로 파일을 읽으면, 파일 로딩이 끝날 때까지 게임 전체가 멈춰버려 사용자는 '프리징' 현상을 겪게 됩니다.
    -   **해결**: 이 문제를 해결하기 위해 파일 로딩을 **별도의 워커 스레드**에 맡깁니다. 워커 스레드가 백그라운드에서 블로킹 방식으로 파일을 읽는 동안, 메인 스레드는 로딩 화면 애니메이션을 보여주거나 배경 음악을 재생하는 등 다른 작업을 계속 수행하여 긍정적인 사용자 경험을 유지합니다. 로딩이 완료되면 워커 스레드가 메인 스레드에 이를 알리고, 메인 스레드는 비로소 맵 전환을 수행합니다.

Non-blocking I/O와 이벤트 기반 I/O 모델을 이해하고 적절히 활용하는 것은 고성능, 고확장성 게임 서버를 개발하는 데 필수적인 지식입니다.