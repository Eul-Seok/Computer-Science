# 12. Blocking과 Non-blocking, Synchronous와 Asynchronous

네트워크 프로그래밍, 특히 서버 개발에서 **Blocking/Non-blocking**과 **Synchronous/Asynchronous** 개념은 시스템의 성능과 반응성을 결정하는 중요한 요소입니다. 이 네 가지 개념은 종종 혼용되거나 혼동되지만, 각각 다른 관점에서 동작 방식을 설명합니다.

## 1. Blocking vs Non-blocking

**Blocking**과 **Non-blocking**은 주로 <b>제어권(Control)</b>의 관점에서 동작을 설명합니다. 즉, 함수를 호출했을 때 호출자(Caller)가 제어권을 즉시 돌려받는지, 아니면 작업이 완료될 때까지 기다려야 하는지를 나타냅니다.

-   **Blocking (블로킹)**
    -   **정의**: 함수를 호출했을 때, 호출된 함수가 작업을 완료할 때까지 호출자에게 제어권을 돌려주지 않는 방식입니다. 호출자는 작업이 끝날 때까지 기다려야 합니다.
    -   **특징**: 작업이 완료될 때까지 다른 작업을 수행할 수 없습니다. 구현이 간단하지만, 대기 시간 동안 자원이 낭비될 수 있습니다.

-   **Non-blocking (논블로킹)**
    -   **정의**: 함수를 호출했을 때, 호출된 함수가 작업을 완료하기 전에 즉시 호출자에게 제어권을 돌려주는 방식입니다. 호출자는 제어권을 돌려받아 다른 작업을 계속 수행할 수 있습니다.
    -   **특징**: 호출자는 작업을 요청한 후 즉시 다른 작업을 수행할 수 있습니다. 작업의 완료 여부는 나중에 별도로 확인해야 합니다.

## 2. Synchronous vs Asynchronous

**Synchronous**와 **Asynchronous**는 주로 <b>작업 완료 여부(Result)</b>의 관점에서 동작을 설명합니다. 즉, 함수를 호출했을 때 작업의 결과(완료 여부)를 즉시 알 수 있는지, 아니면 나중에 통보받는지를 나타냅니다.

-   **Synchronous (동기)**
    -   **정의**: 함수를 호출했을 때, 호출된 함수의 작업이 완료된 후에야 호출자에게 결과가 반환되는 방식입니다. 호출자는 작업의 완료를 기다립니다.
    -   **특징**: 작업의 순서가 직렬적으로 진행됩니다. 결과가 반환될 때까지 다음 작업으로 넘어가지 않습니다.

-   **Asynchronous (비동기)**
    -   **정의**: 함수를 호출했을 때, 호출된 함수의 작업이 완료되기 전에 호출자에게 제어권을 돌려주고, 작업이 완료되면 콜백(Callback)이나 이벤트(Event) 등을 통해 나중에 결과를 통보받는 방식입니다.
    -   **특징**: 작업의 순서가 병렬적으로 진행될 수 있습니다. 호출자는 결과를 기다리지 않고 다른 작업을 수행할 수 있습니다.

## 3. 조합 및 관계

이 네 가지 개념은 서로 독립적이지만, 실제 시스템에서는 조합되어 사용됩니다.

-   **Blocking-Synchronous**: 가장 일반적인 형태. 함수 호출 후 작업 완료까지 대기하며, 결과도 작업 완료 시점에 받습니다. (예: 일반적인 파일 읽기)
-   **Non-blocking-Synchronous**: 호출 후 제어권을 즉시 받지만, 작업 완료 여부를 주기적으로 확인(Polling)해야 합니다. (예: `select()` 함수를 이용한 I/O)
> - **I/O (Input/Output)**: 입출력. 컴퓨터가 디스크, 네트워크 등 외부 장치와 데이터를 주고받는 작업을 의미합니다.
-   **Blocking-Asynchronous**: 드물게 사용되지만, 별도의 스레드에서 블로킹 작업을 수행하고, 완료되면 메인 스레드에 콜백을 전달하는 방식입니다.
-   **Non-blocking-Asynchronous**: 호출 후 제어권을 즉시 받고, 작업 완료 시 콜백이나 이벤트로 통보받습니다. 가장 효율적인 방식으로, 고성능 서버에서 많이 사용됩니다. (예: `epoll()`, `IOCP`)

## 게임 개발 실무 (C++) 관점

게임 개발, 특히 네트워크 기반 게임 서버나 클라이언트 개발에서 Blocking/Non-blocking, Synchronous/Asynchronous 개념은 시스템의 반응성과 처리량에 직접적인 영향을 미칩니다.

-   **게임 서버**:
    -   수많은 클라이언트의 요청을 동시에 처리해야 하므로, 대부분 **Non-blocking-Asynchronous I/O** 모델을 사용합니다. 이를 통해 하나의 스레드가 여러 클라이언트의 I/O 작업을 효율적으로 처리하여 높은 동시 접속자 수를 지원할 수 있습니다.
    > - **스레드(Thread)**: 프로세스 내에서 실행되는 작업의 흐름 단위. 하나의 프로세스는 여러 스레드를 가질 수 있으며, 이를 통해 여러 작업을 동시에 처리하는 것처럼 보이게 할 수 있습니다.
    -   예를 들어, 리눅스 서버는 **`epoll`** 시스템 콜을 사용하여 수천 개의 클라이언트 소켓을 단일 스레드로 모니터링할 수 있습니다. `epoll`은 감시하던 소켓 중 데이터 수신이 가능한 소켓이 생길 때만 알려주므로, 서버는 유휴 상태의 클라이언트를 기다리느라 자원을 낭비하지 않고 실제 작업이 필요한 소켓만 효율적으로 처리할 수 있습니다.
    > - **시스템 콜(System Call)**: 운영체제의 기능을 사용하기 위해 프로그램이 커널에 요청을 보내는 통로. 파일 시스템 접근, 네트워크 통신 등 특권이 필요한 작업을 수행할 때 사용됩니다.
    -   만약 블로킹 I/O를 사용하면 한 클라이언트의 I/O 작업이 지연될 때 전체 서버 스레드가 멈출 수 있으므로, 게임 서버에서는 블로킹 I/O를 피하거나 별도의 **워커 스레드**에서 처리해야 합니다.
    > - **워커 스레드(Worker Thread)**: 메인 스레드의 부담을 덜기 위해, 시간이 오래 걸리는 특정 작업을 전담하여 처리하는 별도의 스레드.

-   **게임 클라이언트**:
    -   클라이언트의 UI(User Interface)는 항상 반응성을 유지해야 합니다. 예를 들어, 메인 UI 스레드에서 블로킹 방식으로 대용량 리소스를 로딩하면, 로딩이 끝날 때까지 게임 화면 전체가 멈추고 유저의 입력을 처리할 수 없는 '프리징(Freezing)' 현상이 발생합니다.
    -   따라서 클라이언트에서도 네트워크 통신, 리소스 로딩 등은 별도의 스레드에서 **비동기적**으로 처리하여 메인 스레드가 렌더링이나 사용자 입력 처리를 계속할 수 있도록 해야 합니다.
    -   C++에서는 `std::async`, `std::thread` 등을 사용하거나, C++20의 <b>코루틴(Coroutine)</b>을 활용할 수 있습니다. 특히 코루틴은 비동기 코드를 마치 동기 코드처럼 순차적으로 작성할 수 있게 해주어, 복잡한 비동기 로직의 가독성과 유지보수성을 획기적으로 높여줍니다.
    > - **코루틴(Coroutine)**: 함수의 실행을 중간에 중단했다가 나중에 원하는 시점부터 다시 재개할 수 있는 함수. 이를 이용해 비동기 작업을 콜백 지옥 없이 간결하게 표현할 수 있습니다.

이러한 개념들을 이해하고 적절히 활용하는 것은 고성능, 고반응성 게임을 개발하는 데 필수적인 역량입니다.