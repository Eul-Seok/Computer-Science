# 05. HTTP와 WebSocket의 차이점

HTTP와 WebSocket은 현대 웹 애플리케이션을 구성하는 핵심 통신 프로토콜입니다. 두 프로토콜은 각기 다른 목적을 위해 설계되었으며, **통신 방식**과 **연결 상태 유지** 여부에서 근본적인 차이를 보입니다.

애플리케이션의 요구사항에 맞는 올바른 프로토콜을 선택하기 위해 두 기술의 차이점을 명확히 이해하는 것이 중요합니다.

---

## 1. HTTP (HyperText Transfer Protocol)

HTTP는 클라이언트가 서버에 **요청(Request)을 보내면, 서버가 이에 응답(Response)하는 방식**으로 동작하는 단방향 프로토콜입니다. 웹 브라우저에서 웹 페이지나 데이터를 불러오는 대부분의 통신이 HTTP를 기반으로 이루어집니다.

### 주요 특징

- **비연결성 (Connectionless)**: 클라이언트의 요청에 대해 서버가 응답을 마치면 맺었던 연결을 끊습니다.
  - **장점**: 서버 자원을 효율적으로 사용할 수 있습니다.
  - **단점**: 매번 요청 시마다 새로 연결해야 하므로, 연결 수립에 따른 오버헤드가 발생합니다.
- **무상태 (Stateless)**: 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며, 이전 통신 기록을 유지하지 않습니다.
  - 각 요청은 독립적인 트랜잭션으로 취급됩니다.
  - 상태 유지가 필요한 경우, 쿠키(Cookie)나 세션(Session), JWT 같은 기술을 사용해야 합니다.

### 실시간 통신의 한계

HTTP는 구조적으로 서버가 클라이언트에게 먼저 데이터를 보낼 수 없습니다. 이 때문에 실시간에 가까운 통신을 구현하기 위해 아래와 같은 방법을 사용해야 합니다.

- **폴링 (Polling)**: 클라이언트가 일정한 주기로 서버에 새로운 데이터가 있는지 물어보는 방식입니다. 불필요한 요청이 많아져 비효율적이고 서버 부하를 가중시킵니다.
- **롱 폴링 (Long-Polling)**: 클라이언트가 요청을 보내고, 서버는 새로운 데이터가 생길 때까지 응답을 지연시키는 방식입니다. 폴링보다 효율적이지만, 여전히 요청-응답 모델의 한계를 가집니다.

---

## 2. WebSocket

WebSocket은 **하나의 TCP 연결 위에서 클라이언트와 서버 간의 실시간 양방향(Full-duplex) 통신**을 가능하게 하는 프로토콜입니다. HTTP와 달리 서버가 원할 때 언제든지 클라이언트에 데이터를 보낼 수 있습니다.

### 주요 특징

- **양방향 통신 (Full-duplex)**: 클라이언트와 서버 모두 언제든지 서로에게 데이터를 전송할 수 있습니다. (마치 전화 통화처럼)
- **연결 지향 (Stateful)**: 한 번 연결이 수립되면, 명시적으로 연결을 닫기 전까지 계속 유지됩니다.
- **낮은 오버헤드**: 최초 연결은 HTTP를 통해 '핸드셰이크' 과정을 거치지만, 일단 연결이 수립된 후에는 매우 가벼운 데이터 프레임만 주고받습니다. HTTP 헤더와 같은 불필요한 메타데이터가 없어 통신 부하가 적습니다.

### 동작 방식

1.  **핸드셰이크 (Handshake)**: 클라이언트가 HTTP 요청 헤더에 `Upgrade: websocket`을 담아 보내 WebSocket 연결을 요청합니다.
  > 핸드셰이크: 통신을 시작하기 전에 서로의 통신 규약이나 보안 설정 등을 협의하는 과정.
2.  **연결 수립**: 서버가 요청을 받아들이면 `101 Switching Protocols` 상태 코드로 응답하여 프로토콜 전환을 알립니다.
3.  **데이터 통신**: 이제부터 해당 연결은 WebSocket 프로토콜을 통해 양방향으로 데이터를 자유롭게 주고받습니다.

---

## 3. HTTP vs. WebSocket 핵심 비교

| 구분 | HTTP | WebSocket |
| :--- | :--- | :--- |
| **통신 방식** | 단방향 (Client → Server) | 양방향 (Client ↔ Server) |
| **연결 상태** | 비연결형 (요청/응답 후 해제) | 연결 지향형 (지속 유지) |
| **상태** | 무상태 (Stateless) | 상태 유지 (Stateful) |
| **요청 주체** | 항상 클라이언트 | 클라이언트 또는 서버 |
| **실시간성** | Polling/Long-Polling 필요 | 실시간 통신에 최적화 |
| **오버헤드** | 헤더로 인해 상대적으로 큼 | 최초 연결 후 매우 작음 |
| **주요 사용처** | 웹 페이지 로딩, REST API | 실시간 채팅, 주식 시세, 멀티플레이 게임 |

---

## 4. HTTP/2, HTTP/3는 WebSocket을 대체할 수 있는가?

결론부터 말하면, **아니오**. HTTP/2와 HTTP/3는 HTTP의 성능을 개선하기 위한 기술이지, WebSocket의 실시간 양방향 통신 목적을 대체하지는 못합니다.

- **HTTP/2**: 하나의 TCP 연결에서 여러 요청/응답을 동시에 처리하는 <b>멀티플렉싱(Multiplexing)</b>과 헤더 압축 등을 통해 성능을 높였습니다.
    > 멀티플렉싱: 하나의 통신 채널을 통해 여러 데이터를 동시에 주고받는 기술.

    **서버 푸시(Server Push)** 기능이 있지만, 클라이언트의 요청에 대한 응답으로 리소스를 밀어주는 방식이라 WebSocket처럼 서버가 임의의 데이터를 자유롭게 보내는 것과는 다릅니다.
    > 서버 푸시: 클라이언트의 명시적인 요청 없이 서버가 필요한 리소스를 미리 보내주는 기능.

- **HTTP/3**: TCP 대신 UDP 기반의 **QUIC 프로토콜**을 사용하여 연결 수립 시간을 단축하고 패킷 손실에 더 잘 대응합니다. (Head-of-Line Blocking 문제 해결)
  > Head-of-Line Blocking: 여러 데이터가 순서대로 처리될 때, 앞선 데이터의 지연이 뒤따르는 데이터의 처리까지 막는 현상.

  > QUIC 프로토콜: UDP 기반으로 설계되어 HTTP/2의 단점을 개선하고, 더 빠르고 안정적인 연결을 제공하는 프로토콜.

두 버전 모두 HTTP의 **요청-응답 모델**이라는 근본적인 패러다임은 그대로 유지합니다. 따라서 지속적인 실시간 데이터 푸시가 필요한 환경에서는 여전히 WebSocket이 가장 적합한 솔루션입니다.

---

## 5. 보안

HTTP와 WebSocket 모두 TLS/SSL을 통해 통신 내용을 암호화할 수 있습니다.
  > TLS/SSL: 인터넷 통신을 암호화하여 데이터의 보안과 무결성을 보장하는 프로토콜.

- **HTTPS**: HTTP + TLS/SSL
- **WSS (WebSocket Secure)**: WebSocket + TLS/SSL (`wss://` 스키마 사용)
    > 스키마: URI(Uniform Resource Identifier)의 첫 부분으로, 해당 리소스에 접근하는 데 사용될 프로토콜(통신 규약)을 지정합니다. 예를 들어, 'https://'는 HTTP Secure 프로토콜을, 'wss://'는 WebSocket Secure 프로토콜을 사용하겠다는 의미입니다.

암호화된 채널을 사용하면 중간자 공격(Man-in-the-middle attack)을 방지하고 데이터 보안을 확보할 수 있습니다.
  > 중간자 공격: 통신하는 두 당사자 사이에 끼어들어 메시지를 가로채거나 위변조하는 공격 방식.

---

## 6. 언제 무엇을 사용해야 할까?

### HTTP (HTTP/2, HTTP/3 포함)
- **클라이언트가 필요할 때만 데이터를 요청하는 경우**
  - 웹 페이지, 뉴스 기사, 이미지, 동영상 등 정적 콘텐츠 조회
  - 게시글 작성, 상품 주문 등 신뢰성이 중요한 단발성 트랜잭션
  - 웹 페이지, 뉴스 기사, 이미지, 동영상 등 정적 콘텐츠 조회
  - 대부분의 **REST API** 통신

### WebSocket
- **서버에서 발생하는 이벤트를 클라이언트에 즉시 전달해야 하는 경우**
  - **실시간 채팅**: 상대방의 메시지를 바로 받아야 함
  - **온라인 게임**: 다른 플레이어의 움직임, 서버 이벤트 등을 지연 없이 동기화
  - **금융/주식**: 변동되는 시세를 실시간으로 차트에 표시
  - **실시간 협업 툴**: 여러 사용자의 동시 편집 내용을 즉시 반영

---

## 7. 게임 개발에서의 활용 예시

게임에서는 두 프로토콜의 장점을 모두 활용하는 하이브리드 접근 방식이 일반적입니다.

- **HTTP 사용**:
  - **신뢰성이 중요한 데이터**: 로그인, 회원가입, 상점에서의 아이템 구매, 유저 프로필 조회, 랭킹 보드 확인 등
  - **구현의 용이성**: REST API 형태로 기능을 구현하고 관리하기 편리함

- **WebSocket 사용**:
  - **지연에 민감한 실시간 데이터**: 실시간 멀티플레이 로직(플레이어 위치, 스킬 사용, 피격 판정), 게임 내 채팅 등
  - **서버 주도 이벤트 전송**: 서버가 모든 클라이언트에게 특정 이벤트(예: 게임 시작, 공지)를 동시에 알려야 할 때

> **실무 Tip**: 대규모 동시 접속을 처리하는 WebSocket 서버는 Node.js, Netty, Go 등 **비동기 이벤트 기반** 아키텍처로 구현하는 것이 효율적입니다. 또한, 연결이 끊어지지 않았는지 주기적으로 확인하는 **하트비트(Heartbeat)** 메커니즘 구현이 필수적입니다.
  
  > 하트비트: 연결이 활성 상태인지 주기적으로 확인하기 위해 주고받는 작은 신호.

---

## 결론

HTTP와 WebSocket은 경쟁 관계가 아닌, **상호 보완적인 관계**입니다.

- **HTTP**는 웹의 근간을 이루는 **요청-응답** 통신의 표준입니다.
- **WebSocket**은 이 한계를 넘어 **실시간 양방향** 소통이 필요할 때 사용하는 강력한 무기입니다.

따라서 개발자는 만들고자 하는 애플리케이션의 특성(실시간성, 데이터 교환 빈도, 신뢰성 요구 수준)을 정확히 파악하고, 각 상황에 가장 적합한 프로토콜을 선택하여 최적의 사용자 경험을 제공해야 합니다.
