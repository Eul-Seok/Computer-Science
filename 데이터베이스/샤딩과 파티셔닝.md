# 18. 샤딩과 파티셔닝

샤딩(Sharding)과 파티셔닝(Partitioning)은 모두 대용량 데이터를 분할하여 관리 효율과 성능을 높이는 기법이지만, 적용 범위와 목적이 다릅니다.

## 1. 파티셔닝 (Partitioning)
-   **정의**: **하나의 DB 내에서** 거대한 테이블 하나를 논리적인 여러 개의 작은 테이블(파티션)으로 나누는 것입니다.
-   **목적**: 데이터가 너무 많아 조회나 관리가 어려운 단일 테이블의 성능 및 관리 효율을 높이는 것입니다.
-   **예시**: 수억 건의 로그 데이터가 담긴 `log` 테이블을 '월(month)' 기준으로 파티셔닝하면, 특정 월의 로그를 조회할 때 전체 테이블이 아닌 해당 월의 파티션만 스캔하여 조회 속도를 크게 높일 수 있습니다.

### 파티셔닝의 주요 유형
-   **범위 파티셔닝 (Range Partitioning)**: 날짜, 가격 등 연속적인 값의 범위를 기준으로 분할합니다. (예: 1월 데이터, 2월 데이터...)
-   **리스트 파티셔닝 (List Partitioning)**: 지역, 국가 코드 등 미리 정해진 값의 목록에 따라 분할합니다. (예: '서울' 파티션, '부산' 파티션...)
-   **해시 파티셔닝 (Hash Partitioning)**: 파티션 키의 해시 값을 기준으로 데이터를 균등하게 분산합니다. 특정 데이터가 몰리는 현상을 방지하는 데 유용합니다.
-   **컴포지트 파티셔닝 (Composite Partitioning)**: 위의 기법들을 조합하여 사용합니다. (예: 날짜로 범위 분할 후, 사용자 ID로 해시 분할)

## 2. 샤딩 (Sharding)
-   **정의**: **여러 개의 DB 서버로** 데이터를 물리적으로 분산 저장하는 것입니다. 데이터베이스 자체를 <b>수평 확장(Scale-out)</b>하는 구조입니다.
> - **수평 확장(Scale-out)**: 비슷한 사양의 서버 대수를 늘려 전체 시스템의 처리 능력을 향상시키는 방식. 반대말은 서버 자체의 사양을 높이는 수직 확장(Scale-up)입니다.
-   **목적**: 단일 데이터베이스 서버가 감당할 수 없는 대규모의 쓰기/읽기 트래픽을 여러 서버로 분산하여, 시스템 전체의 확장성과 성능을 확보하는 것입니다.
-   **예시**: 전 세계 사용자를 대상으로 하는 서비스에서, 사용자 ID나 지역을 기준으로 DB 서버를 '아시아 샤드', '유럽 샤드', '북미 샤드' 등으로 분리하여 운영합니다.

### 샤딩의 구현 방식
-   **애플리케이션 레벨 샤딩**: 애플리케이션 코드에서 샤드 키를 기준으로 어떤 DB 서버에 접근할지 직접 결정하고 라우팅합니다. 가장 유연하지만, 애플리케이션이 복잡해집니다.
-   **미들웨어 샤딩**: 애플리케이션과 데이터베이스 서버 사이에 <b>프록시(미들웨어)</b>를 두는 방식입니다. 애플리케이션은 미들웨어에만 쿼리를 보내고, 미들웨어가 적절한 샤드로 쿼리를 분배합니다. (예: Vitess, ProxySQL)
> - **프록시(Proxy)**: 클라이언트와 서버 사이에서 요청과 응답을 중계해주는 서버. 캐싱, 로드밸런싱, 보안 등 다양한 역할을 수행합니다.
-   **네이티브 샤딩 (DB 레벨 샤딩)**: 데이터베이스 자체에서 샤딩 기능을 제공하고 관리합니다. 개발자에게 가장 편리하지만, 특정 DB에 종속됩니다. (예: MongoDB, CockroachDB)

## 3. 비교 요약

| 구분 | 파티셔닝 (Partitioning) | 샤딩 (Sharding) |
| :--- | :--- | :--- |
| **목적** | 단일 테이블의 성능 및 관리 효율 향상 | 데이터베이스 전체의 부하 분산 및 확장성 확보 |
| **분할 단위** | 테이블 내부의 논리적 분할 | 데이터베이스 자체의 물리적 분할 |
| **분산 위치** | 단일 데이터베이스 서버 | 여러 데이터베이스 서버 |
| **장점** | 쿼리 성능 향상, 데이터 관리 용이 | 쓰기/읽기 성능의 수평적 확장 가능 |
| **단점** | 서버 한계 초과 시 확장 불가 | 샤드 간 데이터 조인(JOIN), 트랜잭션, 일관성 유지가 복잡하고 어려움 |

## 4. 실무적 고려사항 및 확장 전략

-   **파티셔닝 운영 시 주의점**:
    -   **쿼리 최적화**: 파티셔닝의 핵심 성능 비결은 <b>파티션 프루닝(Partition Pruning)</b>입니다. 쿼리의 `WHERE` 조건에 파티션 키가 포함되면, **옵티마이저**가 불필요한 파티션을 스캔하지 않고 필요한 파티션에만 접근하여 조회 성능을 크게 향상시킵니다.
    > - **파티션 프루닝(Partition Pruning)**: '가지치기'라는 의미로, 쿼리 실행 시 불필요한 파티션을 제외하고 꼭 필요한 파티션만 탐색하는 최적화 기술.
    > - **옵티마이저(Optimizer)**: 사용자가 보낸 SQL 쿼리를 가장 효율적으로 실행할 수 있는 최적의 경로(실행 계획)를 찾아주는 데이터베이스의 핵심 컴포넌트.
    -   **주의점**: 만약 쿼리 조건에 파티션 키가 포함되지 않으면, 데이터베이스는 **모든 파티션을 다 스캔**해야 하므로 오히려 성능이 저하될 수 있습니다.
    -   **서버 한계**: 결국 **하나의 DB 서버 자원** 내에서 동작하므로, 서버의 CPU, I/O 성능 한계를 넘어서지는 못합니다.

-   **샤딩 운영 시 주의점**:
    -   **샤드 키(Shard Key) 설계**: 샤딩의 성패를 좌우하는 가장 중요한 요소입니다. 샤드 키를 잘못 설계하면 데이터가 특정 샤드에만 몰리는 **핫스팟(Hot Spot)** 문제가 발생하여, 샤딩의 목적인 부하 분산이 실패하게 됩니다.
    > - **핫스팟(Hot Spot)**: 시스템의 부하가 특정 지점에 집중되는 현상. 샤딩에서는 특정 서버에만 트래픽이 몰리는 것을 의미합니다.
    -   **샤드 간 복잡성**: 샤딩 환경에서는 여러 샤드에 걸친 JOIN이나 **분산 트랜잭션**을 DB가 자동으로 처리해주지 못하는 경우가 많습니다. 이러한 복잡한 로직은 **애플리케이션 레벨에서 데이터를 여러 번 조회하고 조합**하는 방식으로 해결해야 할 수 있습니다.
    > - **분산 트랜잭션(Distributed Transaction)**: 여러 개의 독립된 데이터베이스 서버에 걸쳐 있는 작업을 하나의 논리적 트랜잭션으로 묶어 처리하는 것. 구현이 매우 복잡합니다.
    -   **리샤딩(Re-sharding)의 어려움**: 서비스 운영 중 샤드의 개수를 늘리거나 샤드 키를 변경하는 리샤딩 작업은, 대규모 데이터를 서비스 중단 없이 이전해야 하는 매우 복잡하고 위험한 작업입니다.

-   **단계적 확장 전략**: 따라서 실무에서는 보통 아래와 같은 단계적 확장 전략을 고려합니다.
    1.  **1단계**: 단일 DB에서 쿼리 튜닝, 인덱싱, 반정규화 등으로 최대한 성능을 확보합니다.
    2.  **2단계**: 특정 테이블의 크기가 너무 커져 문제가 되면, 해당 테이블에 **파티셔닝**을 적용합니다.
    3.  **3단계**: 파티셔닝으로도 해결되지 않고 DB 서버 자체의 부하(CPU, I/O, Connection 등)가 한계에 도달했을 때, 최후의 수단으로 **샤딩**을 고려합니다.