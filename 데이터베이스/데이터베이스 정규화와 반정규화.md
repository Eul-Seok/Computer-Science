# 15. 데이터베이스 정규화와 반정규화

데이터베이스 설계에서 데이터의 중복을 최소화하고 무결성을 보장할 것인가, 아니면 조회 성능을 위해 중복을 감수할 것인가는 중요한 선택입니다. **정규화(Normalization)**와 **반정규화(Denormalization)**는 이 균형을 조절하는 핵심적인 데이터 모델링 전략입니다.

## 1. 정규화 (Normalization)

**정의**: 데이터의 중복을 최소화하고 **데이터 무결성**을 보장하기 위해, 테이블을 논리적인 단위로 분리하고 구조화하는 과정입니다.
> - **데이터 무결성(Data Integrity)**: 데이터베이스 내의 데이터가 항상 정확하고 일관된 상태를 유지하는 것을 의미합니다.

**목표**: 정규화의 가장 큰 목표는 데이터 변경 시 발생할 수 있는 **이상 현상(Anomaly)**을 방지하는 것입니다.
> - **이상 현상(Anomaly)**: 데이터 중복으로 인해 삽입, 갱신, 삭제 시 원치 않는 문제가 발생하는 것.

### 정규화 단계 (Normalization Forms)
정규화는 **함수 종속성**을 분석하여 적용하며, 여러 단계로 나뉩니다. 일반적으로 3정규형까지 만족시키는 것을 목표로 합니다.
> - **함수 종속(Functional Dependency)**: 테이블의 어떤 컬럼(A)의 값이 다른 컬럼(B)의 값을 유일하게 결정하는 관계. `A → B`로 표기하며, "B는 A에 함수적으로 종속된다"고 말합니다.

-   **제1정규형 (1NF)**: 테이블의 모든 컬럼 값이 **원자값(Atomic Value)**을 갖도록 분해합니다.
> - **원자값(Atomic Value)**: 더 이상 분해할 수 없는 단일 값. 예를 들어, 'CS101, CS202'는 원자값이 아니지만, 'CS101'은 원자값입니다.
-   **제2정규형 (2NF)**: 제1정규형을 만족하고, 기본 키의 일부에만 종속되는 **부분 함수 종속**을 제거합니다.
-   **제3정규형 (3NF)**: 제2정규형을 만족하고, 기본 키가 아닌 다른 일반 컬럼에 종속되는 **이행 함수 종속**을 제거합니다.
-   **BCNF (Boyce-Codd 정규형)**
    -   **정의**: 제3정규형보다 엄격한 형태로, 모든 **결정자가 후보 키**가 되도록 합니다.
    > - **결정자**: 테이블에서 다른 컬럼의 값을 고유하게 결정하는 컬럼(들)의 집합.
    > - **후보 키(Candidate Key)**: 테이블의 행을 유일하게 식별할 수 있는 속성(컬럼)의 최소 집합. 기본 키(Primary Key)는 여러 후보 키 중 하나를 선택한 것입니다.
    -   **이유**: 3NF에서 드물게 발생하는 일부 이상 현상을 해결하기 위해 사용됩니다.
    -   **BCNF 위반 예시**: `(학생_ID, 과목명, 담당_교수)` 테이블에서, 기본 키가 `(학생_ID, 과목명)`이고, "한 교수는 한 과목만 담당한다"는 제약이 있다고 가정해봅시다.
        -   이 경우 `담당_교수`가 `과목명`을 결정합니다 (`담당_교수` → `과목명`).
        -   하지만 `담당_교수`는 이 테이블의 후보 키가 아니므로 BCNF를 위반합니다. (3NF는 만족)
        -   이로 인해 교수가 담당 과목을 변경할 때 여러 행을 수정해야 하는 등 갱신 이상이 발생할 수 있습니다.

#### 정규화 과정 예시
**[비정규형 테이블]**
하나의 행에 수강 과목 정보가 반복되는 그룹을 가짐.
| 학생_ID | 학생_이름 | 학과명 | 학과_전화번호 | 수강_과목들 |
| :--- | :--- | :--- | :--- | :--- |
| 100 | 김철수 | 컴퓨터공학 | 1234 | (CS101, 자료구조, A+), (CS202, 운영체제, A) |

**[제1정규형(1NF)]**
반복 그룹을 제거하여 모든 컬럼이 원자값을 갖게 함. 기본 키는 `(학생_ID, 과목_코드)`.
| 학생_ID | 학생_이름 | 학과명 | 학과_전화번호 | 과목_코드 | 과목명 | 성적 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 100 | 김철수 | 컴퓨터공학 | 1234 | CS101 | 자료구조 | A+ |
| 100 | 김철수 | 컴퓨터공학 | 1234 | CS202 | 운영체제 | A |

**[제2정규형(2NF)]**
부분 함수 종속(기본 키 일부에만 종속)을 제거. `학생_이름`, `학과명` 등은 `학생_ID`에만 종속되므로 분리.

**수강 테이블** (기본 키: `학생_ID`, `과목_코드`)
| 학생_ID | 과목_코드 | 성적 |
| :--- | :--- | :--- |
| 100 | CS101 | A+ |
| 100 | CS202 | A |

**학생 테이블** (기본 키: `학생_ID`)
| 학생_ID | 학생_이름 | 학과명 | 학과_전화번호 |
| :--- | :--- | :--- | :--- |
| 100 | 김철수 | 컴퓨터공학 | 1234 |

**[제3정규형(3NF)]**
이행 함수 종속(일반 컬럼에 종속)을 제거. `학과_전화번호`는 `학과명`에 종속되므로 분리.

**수강 테이블** (2NF와 동일)

**학생 테이블** (기본 키: `학생_ID`)
| 학생_ID | 학생_이름 | 학과_ID |
| :--- | :--- | :--- |
| 100 | 김철수 | CS |

**학과 테이블** (기본 키: `학과_ID`)
| 학과_ID | 학과명 | 학과_전화번호 |
| :--- | :--- | :--- |
| CS | 컴퓨터공학 | 1234 |

## 2. 반정규화 (Denormalization)

**정의**: 조회 성능 향상을 위해 의도적으로 데이터 중복을 허용하거나 테이블 구조를 변경하는 과정입니다. `JOIN` 연산을 줄이는 것이 주된 목표입니다.

### 주요 반정규화 기법
-   **테이블 병합**: 1:1 관계이거나, 1:N 관계라도 `JOIN`이 매우 빈번하게 발생할 경우 두 테이블을 하나의 테이블로 병합하여 `JOIN` 비용을 제거합니다.
-   **중복 컬럼 추가**: `JOIN`을 통해 가져와야 하는 다른 테이블의 컬럼을 현재 테이블에 미리 추가합니다. (예: `post` 테이블에 `user_name`을 중복 저장하여 `user` 테이블과의 `JOIN`을 생략)
-   **파생/집계 컬럼 추가**: 조회 시 계산이 필요한 값을 미리 계산하여 컬럼으로 저장합니다. (예: `post` 테이블에 댓글 수를 저장하는 `comment_count` 컬럼을 추가하고, 댓글이 달릴 때마다 값을 갱신하여 매번 `COUNT(*)` 연산을 피함)
-   **인덱스 테이블 추가**: 특정 조회 패턴만을 위해, 원본 테이블의 데이터 일부를 복제하여 별도의 '인덱스 역할 테이블'을 만듭니다. 원본 테이블보다 작고 특정 쿼리에 최적화되어 있어 조회 성능을 높일 수 있습니다.
-   **파티셔닝과의 조합**: 대용량 테이블을 반정규화하여 조회 성능을 높인 후, 그 테이블을 다시 날짜나 지역 등의 기준으로 파티셔닝하여 관리 효율과 추가적인 성능 향상을 꾀하는 전략입니다.

### 반정규화의 위험과 동기화 비용
반정규화는 조회 성능을 높여주지만, 데이터 중복으로 인한 **동기화 비용**과 **무결성 저하**라는 위험을 감수해야 합니다.
-   **예시**: `post` 테이블에 `user_name`을 중복 저장했는데, 만약 사용자가 자신의 이름을 변경한다면, 해당 사용자가 작성한 모든 `post` 테이블의 `user_name`을 찾아 일일이 갱신해야 합니다. 이 과정을 누락하면 데이터가 불일치하게 되며(무결성 저하), 모든 데이터를 찾아 갱신하는 비용은 쓰기 성능을 크게 저하시킬 수 있습니다.

## 3. 정규화와 반정규화의 트레이드오프

정규화와 반정규화는 상호 배타적인 관계가 아니며, 각각 명확한 장단점을 가집니다.

| 구분 | 정규화 (Normalization) | 반정규화 (Denormalization) |
| :--- | :--- | :--- |
| **강점** | **쓰기/갱신** 시 무결성 유지 | **읽기** 시 성능 향상 |
| **장점** | - 데이터 무결성 극대화<br>- 데이터 중복 최소화<br>- 이상 현상 방지<br>- 유지보수 용이 | - `JOIN` 감소로 인한 조회 성능 향상 |
| **단점** | - 과도한 `JOIN`으로 인한 조회 성능 저하 가능성 | - 데이터 중복 증가<br>- 데이터 무결성 저하 위험<br>- 데이터 관리 복잡성 증가 |

### 핵심 고려사항: 읽기 vs. 쓰기 비율
**설계 초기 단계에서 가장 중요하게 고려해야 할 지표는 예상되는 데이터의 읽기(Read)와 쓰기(Write/Update) 비율입니다.**

-   **쓰기/갱신 위주 시스템 (Write-heavy)**: 데이터의 삽입/수정/삭제가 빈번하고, 데이터 무결성이 매우 중요한 **OLTP(Online Transaction Processing)** 시스템에서는 **정규화**를 우선적으로 적용해야 합니다. 중복 데이터 갱신 비용이 조회 성능의 이점보다 커질 수 있기 때문입니다.
    > - **OLTP(온라인 트랜잭션 처리)**: 여러 사용자가 실시간으로 데이터베이스의 데이터를 수정하고 조회하는 작업을 처리하는 방식.
    -   **대표적인 예시**: **금융 거래, 결제, 실시간 예약 시스템** 등. 데이터의 정합성이 서비스의 신뢰도와 직결되는 시스템입니다.
-   **읽기 위주 시스템 (Read-heavy)**: 쓰기보다 읽기/조회가 압도적으로 많고, 빠른 응답 속도가 중요한 **OLAP(Online Analytical Processing)** 시스템에서는 **반정규화**를 적극적으로 고려해야 합니다.
    > - **OLAP(온라인 분석 처리)**: 대규모 데이터를 다양한 관점에서 분석하고 요약하여 의사결정을 지원하는 방식.
    -   **대표적인 예시**: **로그 분석, 통계 대시보드, SNS 피드, 데이터 웨어하우스** 등. 약간의 데이터 불일치를 감수하더라도 빠른 조회 속도가 더 중요한 시스템입니다.
    > - **데이터 웨어하우스(Data Warehouse)**: 의사결정을 지원하기 위해, 여러 소스에서 수집된 데이터를 주제별로 통합하여 저장하는 대규모 데이터 저장소.

### 결론: 측정하고 최적화하라
데이터베이스 설계자의 역량은 이 트레이드오프를 이해하고 시스템의 특성에 맞춰 두 전략의 균형점을 찾는 데 있습니다.

> **실무 원칙: "섣부른 최적화는 만악의 근원이다."**
>
> 데이터베이스 설계의 가장 좋은 접근 방식은 **일단 정규화 원칙에 따라 설계를 진행**하는 것입니다. 그 후, 실제 운영 환경과 유사한 조건에서 **성능 테스트를 수행**하여 병목이 되는 특정 쿼리나 테이블을 식별하고, **측정된 데이터에 근거하여** 해당 지점에만 반정규화를 전략적으로 적용해야 합니다.