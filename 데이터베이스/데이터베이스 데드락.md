# 17. 데이터베이스 데드락

<b>데드락(Deadlock)</b>은 둘 이상의 트랜잭션이 서로 상대방이 점유한 **자원**(예: 특정 행의 잠금)을 기다리며 무한히 대기하는 **교착 상태**를 의미합니다.
> - **자원(Resource)**: 데이터베이스에서는 잠금(Lock)의 대상이 되는 모든 것을 의미합니다. 특정 행, 테이블, 페이지, 인덱스 등이 자원이 될 수 있습니다.

> **데드락 발생 시나리오**:
> 1. 트랜잭션 A가 `Player` 테이블의 'user1' 행을 잠그고, 'user2' 행을 잠그려고 시도합니다.
> 2. 동시에 트랜잭션 B는 `Player` 테이블의 'user2' 행을 잠그고, 'user1' 행을 잠그려고 시도합니다.
> 3. 트랜잭션 A는 B가 'user2'를 놓아주길 기다리고, 트랜잭션 B는 A가 'user1'을 놓아주길 기다리며 영원히 멈추게 됩니다.

## 1. 데드락 발생 조건 (Coffman's Conditions)
데드락은 아래의 네 가지 조건이 **모두 동시에** 만족될 때 발생할 수 있습니다. 이 중 하나라도 만족하지 않으면 데드락은 발생하지 않습니다.

-   **상호 배제 (Mutual Exclusion)**: 한 번에 하나의 트랜잭션만이 자원을 사용할 수 있어야 합니다.
-   **점유와 대기 (Hold and Wait)**: 최소한 하나의 자원을 점유하고 있으면서, 다른 트랜잭션이 점유한 자원을 추가로 요청하며 대기해야 합니다.
-   **비선점 (No Preemption)**: 다른 트랜잭션이 점유한 자원을 강제로 빼앗을 수 없어야 합니다. 자원은 점유한 트랜잭션이 자발적으로 놓을 때까지 사용할 수 없습니다.
-   **순환 대기 (Circular Wait)**: 각 트랜잭션이 순환적으로 다음 트랜잭션이 요구하는 자원을 가지고 있어야 합니다. (T1 → T2 → T3 → T1)

## 2. 데드락 해결 방안
DBMS는 데드락을 해결하기 위해 예방, 회피, 탐지/회복 등의 전략을 사용하지만, 대부분의 상용 DBMS는 **동시성**을 최대한 보장하기 위해 **탐지 및 회복** 방식을 주로 사용합니다.
> - **동시성(Concurrency)**: 여러 작업(트랜잭션)이 동시에 실행되는 것처럼 보이게 하는 시스템의 특성. 동시성이 높을수록 시스템의 처리량이 향상됩니다.

-   **탐지 및 회복 (Detection & Recovery)**
    -   **Wait-for-Graph (대기 그래프)**: 트랜잭션 간의 대기 관계를 그래프로 만들어 사이클이 발생하는지 검사하여 데드락을 탐지합니다. 가장 널리 사용되는 방식입니다.
    -   **타임아웃(Timeout)**: 일정 시간 이상 트랜잭션이 대기하면 데드락으로 간주하고, 해당 트랜잭션을 롤백시킵니다. 구현이 간단하지만, 데드락이 아닌데 롤백되는 경우가 생길 수 있습니다.
    -   **희생양 선택 및 롤백**: 데드락이 감지되면, 시스템이 두 트랜잭션 중 하나를 '희생양'으로 선택하여 롤백시킨 후, 잠시 뒤에 다시 실행하도록 합니다.

### 주요 DBMS의 데드락 처리
-   **MySQL (InnoDB)**: `Wait-for-Graph`를 기반으로, 교착 상태를 유발하는 잠금 요청이 들어오는 즉시 데드락을 탐지합니다. 이후 변경량이 가장 적은 트랜잭션을 '희생양'으로 삼아 롤백합니다.
-   **SQL Server**: 기본적으로 백그라운드 스레드(Lock Monitor)가 주기적으로(기본 5초) `Wait-for-Graph`를 검사하여 사이클을 찾고, **롤백 비용**이 가장 적은 트랜잭션을 희생양으로 선택합니다.
> - **롤백 비용(Rollback Cost)**: 트랜잭션을 롤백하는 데 드는 자원의 양. 일반적으로 트랜잭션이 생성한 로그의 양에 비례합니다.
-   **Oracle**: `Wait-for-Graph`를 사용하여 데드락 발생 시점에 즉시 탐지하며, 데드락을 유발한 SQL 문장 하나만 롤백합니다.

## 3. 실무에서의 데드락 방지 전략
DBMS가 데드락을 해결해주지만, 데드락은 그 자체로 성능 저하를 유발하므로 애플리케이션 레벨에서 발생 빈도를 줄이는 노력이 매우 중요합니다.

-   **자원 접근 순서 통일**: 여러 자원을 잠글 때, 모든 트랜잭션이 항상 동일한 순서로 자원에 접근하도록 규칙을 정합니다. (예: 항상 테이블 A를 먼저 잠그고, 그 다음 테이블 B를 잠근다) 이는 **순환 대기** 조건을 깨뜨려 데드락을 효과적으로 방지합니다.
-   **트랜잭션 최소화**: 트랜잭션을 가능한 한 짧게 유지하여 잠금이 걸리는 시간을 최소화합니다. 불필요한 로직을 트랜잭션 밖으로 빼고, 사용자의 입력을 기다리는 등의 작업을 트랜잭션 내에 포함하지 않습니다.
-   **잠금 범위 최소화**: 테이블 전체를 잠그는 대신, 필요한 행(Row)만 잠그도록 쿼리를 신중하게 작성합니다. 적절한 <b>격리 수준(Isolation Level)</b>을 사용하여 불필요한 잠금을 피하는 것도 중요합니다.
> - **격리 수준(Isolation Level)**: 여러 트랜잭션이 동시에 실행될 때, 서로 얼마나 격리될 것인지를 정하는 등급. 수준이 높을수록 안정적이지만 동시성은 저하됩니다.
-   **커밋 또는 롤백 신속 처리**: 애플리케이션 코드에서 트랜잭션을 시작했다면, 로직이 끝나는 즉시 반드시 커밋(Commit) 또는 롤백(Rollback)하여 자원을 해제해야 합니다.