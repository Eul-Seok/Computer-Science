# 16. 트랜잭션과 ACID

**트랜잭션**은 데이터베이스에서 하나의 논리적 작업 단위를 의미하며, 여러 연산이 하나의 묶음처럼 실행됩니다. 트랜잭션이 안정적으로 수행되기 위해서는 아래의 ACID 성질을 반드시 만족해야 합니다.
> - **트랜잭션(Transaction)**: 모두 성공하거나 모두 실패해야 하는 작업들의 묶음. 'All or Nothing'.

## 1. ACID의 4가지 성질

-   **원자성 (Atomicity)**
    -   트랜잭션 내의 모든 작업이 <b>전부 성공하거나, 하나라도 실패하면 전부 실패(롤백)</b>해야 한다는 성질입니다. 데이터의 불완전한 변경을 막아줍니다.
    > - **롤백(Rollback)**: 트랜잭션 처리 중 오류가 발생했을 때, 해당 트랜잭션이 시작되기 이전의 상태로 모든 변경 사항을 되돌리는 작업.
    -   **예시**: 계좌 이체 시, A 계좌의 잔액을 차감하는 작업과 B 계좌의 잔액을 증액하는 작업은 하나의 트랜잭션으로 묶여 원자성을 보장받아야 합니다.

-   **일관성 (Consistency)**
    -   트랜잭션이 실행되기 전과 후 모두 데이터베이스의 상태가 **미리 정의된 규칙과 제약 조건을 위반하지 않는 일관된 상태**를 유지해야 한다는 성질입니다.
    -   **예시**: 외래 키 제약, 특정 컬럼의 값 범위 등의 규칙이 트랜잭션 수행 후에도 깨지지 않아야 합니다.

-   **격리성 (Isolation)**
    -   여러 트랜잭션이 동시에 실행되더라도, 각 트랜잭션은 **서로에게 영향을 주지 않고 독립적으로 수행**된 것처럼 보여야 한다는 성질입니다. 이를 위해 데이터베이스는 <b>잠금(Locking)</b>이나 **MVCC** 같은 동시성 제어 기법을 사용합니다.
    > - **잠금(Locking)**: 특정 데이터에 대해 하나의 트랜잭션이 작업을 마칠 때까지 다른 트랜잭션이 접근하지 못하도록 막는 기법.
    > - **MVCC(Multi-Version Concurrency Control)**: 데이터 변경 시 새로운 버전을 생성하여, 각 트랜잭션이 특정 시점의 버전을 보도록 함으로써 잠금을 최소화하는 동시성 제어 기법.

-   **지속성 (Durability)**
    -   성공적으로 완료된 트랜잭션의 결과는 시스템에 장애가 발생하더라도 **영구적으로 저장**되어야 한다는 성질입니다.
    -   이를 위해 데이터베이스는 변경 내용을 로그 파일에 먼저 기록하고, 이를 기반으로 장애 발생 시 데이터를 복구합니다.

## 2. 심화 개념: 격리 수준과 지속성 구현

### 격리 수준 (Isolation Levels)
격리성은 성능과 트레이드오프 관계에 있어, ANSI SQL 표준은 4가지 격리 수준을 정의합니다. 수준이 높아질수록 안정성은 높아지지만, 동시 처리 성능은 저하될 수 있습니다.

-   **Read Uncommitted (Level 0)**: 다른 트랜잭션이 **커밋**하지 않은 변경 내용까지 읽을 수 있습니다. (가장 낮은 수준)
    > - **커밋(Commit)**: 트랜잭션의 모든 작업이 성공적으로 완료되었음을 데이터베이스에 알리고, 변경 내용을 영구적으로 저장하는 명령.
    -   **Dirty Read**가 발생할 수 있습니다.
    > - **Dirty Read**: 한 트랜잭션이 다른 트랜잭션이 아직 커밋하지 않은, 수정 중인 데이터를 읽는 현상. 상대 트랜잭션이 롤백하면 데이터의 일관성이 깨집니다.
-   **Read Committed (Level 1)**: 커밋된 데이터만 읽을 수 있습니다. 대부분의 DBMS 기본 수준입니다.
    -   Dirty Read를 방지하지만, **Non-Repeatable Read**는 발생할 수 있습니다.
    > - **Non-Repeatable Read**: 한 트랜잭션 내에서 같은 행을 두 번 읽었는데, 그 사이에 다른 트랜잭션이 해당 행을 수정하고 커밋하여 두 결과가 다르게 나타나는 현상.
-   **Repeatable Read (Level 2)**: 트랜잭션이 시작된 시점의 데이터 버전을 읽어, 트랜잭션 내내 일관된 데이터를 보장합니다.
    -   Non-Repeatable Read를 방지하지만, **Phantom Read**는 발생할 수 있습니다.
    > - **Phantom Read**: 한 트랜잭션이 일정 범위의 데이터를 두 번 읽었을 때, 첫 번째 쿼리에는 없던 새로운 행이 두 번째 쿼리에서 나타나는 현상. (유령처럼 없던 데이터가 나타남)
-   **Serializable (Level 3)**: 트랜잭션을 순차적으로 실행하는 것과 같은 가장 엄격한 수준. 모든 동시성 문제를 방지합니다.

### 지속성 구현 기법
-   **WAL (Write-Ahead Logging)**: 데이터베이스의 모든 변경 사항은 실제 데이터 파일에 적용되기 전에, 로그 파일에 먼저 기록됩니다. 시스템 장애 시, 이 로그를 보고 커밋된 트랜잭션을 복구(**Redo**)하거나 롤백된 트랜잭션을 취소(**Undo**)하여 데이터 손실을 막습니다.
    > - **Redo/Undo**: Redo는 로그를 기반으로 커밋된 변경 사항을 재실행하는 것, Undo는 롤백된 변경 사항을 원상 복구하는 것입니다.
-   **체크포인트 (Checkpoint)**: WAL 로그가 무한정 커지는 것을 막기 위해, 주기적으로 메모리(**버퍼 캐시**)에 있는 변경 사항들을 실제 데이터 디스크에 반영하는 시점을 만듭니다. 장애 복구 시, 가장 최근의 체크포인트 이후 로그만 확인하면 되므로 복구 시간이 단축됩니다.
    > - **버퍼 캐시(Buffer Cache)**: 디스크 I/O 성능을 높이기 위해, 자주 사용하는 데이터 페이지를 미리 읽어와 저장해두는 메모리 영역.

## 3. ACID의 트레이드오프와 NoSQL

ACID를 엄격하게 지키면 데이터의 안정성은 극대화되지만, 잠금이나 로깅으로 인한 오버헤드로 성능이 저하될 수 있습니다. 특히 대규모 분산 시스템에서는 이 문제가 더 두드러집니다.

-   **CAP 이론**: 분산 시스템은 아래 세 가지 중 최대 두 가지만 동시에 만족할 수 있다는 이론입니다.
    > - **일관성(Consistency)**: 모든 노드가 동시에 같은 데이터를 보여줘야 한다.
    > - **가용성(Availability)**: 모든 요청에 대해 항상 응답을 받을 수 있어야 한다.
    -   **분할 용인(Partition Tolerance)**: 노드 간 네트워크가 끊겨도 시스템이 계속 동작해야 한다.
    -   네트워크 장애는 피할 수 없으므로(P), 결국 일관성(C)과 가용성(A) 사이에서 선택을 해야 합니다.
-   **BASE 모델**: ACID의 대안으로 NoSQL 데이터베이스에서 채택하는 모델입니다.
    -   **B**asically **A**vailable: 기본적으로 항상 사용 가능해야 한다 (가용성 중시).
    -   **S**oft state: 상태는 외부 입력 없이도 시간에 따라 변할 수 있다.
    -   **E**ventually consistent: 최종적으로는 일관성을 유지한다 (엄격한 즉시 일관성 대신).

결론적으로, 금융 거래처럼 데이터의 정합성이 절대적으로 중요한 시스템은 **RDBMS**와 ACID 모델을, 약간의 불일치를 감수하더라도 가용성과 확장성이 더 중요한 서비스(예: SNS 타임라인, 상품 추천)는 **NoSQL**과 BASE 모델을 선택하는 경향이 있습니다.
> - **RDBMS(관계형 데이터베이스)**: 정해진 스키마에 따라 데이터를 테이블 형태로 저장하는 전통적인 데이터베이스. (예: MySQL, PostgreSQL)
> - **NoSQL(비관계형 데이터베이스)**: 스키마 없이 자유로운 형태로 데이터를 저장하며, 분산 환경에 최적화된 데이터베이스. (예: MongoDB, Cassandra)