# 14. 데이터베이스 인덱스의 원리와 동작

<b>데이터베이스 인덱스(Index)</b>는 **조회(SELECT) 성능을 획기적으로 향상시키기 위해 사용되는 자료구조**입니다.
> - **자료구조(Data Structure)**: 데이터를 효율적으로 저장하고 관리하기 위한 구조. 인덱스에서는 B-Tree, 해시 등이 사용됩니다.

책의 맨 뒤에 있는 '찾아보기'와 같이, 원하는 데이터를 빠르게 찾을 수 있도록 도와주는 역할을 합니다.

> **실무 예시**: 수백만 명의 회원이 있는 `Member` 테이블에서 `email` 컬럼에 인덱스가 없다면, 특정 이메일로 로그인하는 유저를 찾기 위해 매번 전체 회원을 검색해야 합니다. 하지만 `email` 컬럼에 인덱스를 생성하면, 데이터베이스는 B-Tree 구조를 통해 단 몇 번의 탐색만으로 해당 유저를 즉시 찾아낼 수 있습니다.

## 1. 인덱스는 왜 쿼리 속도를 높여주는가?

인덱스가 없는 테이블에서 특정 데이터를 찾으려면, 데이터베이스는 테이블의 모든 행을 처음부터 끝까지 하나씩 확인해야 합니다. 이를 <b>풀 테이블 스캔(Full Table Scan)</b>이라고 하며, 데이터가 많아질수록 탐색 시간은 선형적으로 증가합니다(시간 복잡도: O(N)).

반면, 인덱스를 사용하면 B-Tree와 같은 정렬된 자료구조를 통해 데이터를 탐색합니다. 이를 통해 전체 데이터를 모두 확인하지 않고, 로그 시간 내에 원하는 데이터의 위치를 빠르게 찾아낼 수 있습니다(시간 복잡도: O(log N)). 수백만, 수천만 건의 데이터에서 이는 엄청난 성능 차이를 만듭니다.

## 2. 인덱스의 대표적인 자료구조

### B-Tree (Balanced Tree) 인덱스
-   가장 보편적으로 사용되는 인덱스 자료구조입니다.
> - **B-Tree**: 자식 노드의 개수가 2개 이상일 수 있는 균형 잡힌 트리 구조. 대용량 데이터의 저장 및 검색에 최적화되어 있습니다.
-   항상 정렬된 상태를 유지하며, 트리의 어느 노드에서 루트 노드까지의 거리가 모두 같은 **균형 트리**입니다.
-   **특징**: 특정 값(`=`)을 찾는 것은 물론, 값의 범위(`>`, `<`, `BETWEEN`)를 찾는 데에도 매우 효율적입니다. 대부분의 데이터베이스에서 기본 인덱스 타입으로 사용됩니다.

### 해시(Hash) 인덱스
-   컬럼의 값을 해시 함수에 넣어 나온 해시 값을 기반으로 인덱스를 구축합니다.
-   **특징**: 동등 비교(`=`) 연산에서 O(1)이라는 매우 빠른 속도를 보입니다. 하지만 해시 값은 순서를 보장하지 않으므로, 범위 검색이나 정렬에는 사용할 수 없습니다. 주로 메모리 기반 데이터베이스에서 사용됩니다.

## 3. 인덱스 스캔 방식: Seek vs. Scan

인덱스를 사용한 조회는 크게 두 가지 방식으로 나뉩니다.
-   **인덱스 탐색 (Index Seek)**
    -   B-Tree의 루트부터 시작하여 특정 값을 효율적으로 찾아가는 방식입니다.
    -   `WHERE` 절의 조건이 인덱스 컬럼과 정확히 일치하고, 해당 값의 위치를 바로 찾아갈 수 있을 때 사용됩니다. **가장 이상적이고 빠른 인덱스 활용법**입니다.
-   **인덱스 스캔 (Index Scan)**
    -   인덱스의 리프 노드를 처음부터 끝까지, 또는 특정 범위만큼 순차적으로 탐색하는 방식입니다.
    -   `Index Seek`보다는 느리지만, 테이블 전체를 스캔하는 것보다는 훨씬 효율적입니다. (인덱스는 테이블보다 크기가 작고 정렬되어 있기 때문)
    -   `WHERE` 절의 조건이 인덱스의 첫 번째 컬럼이 아니거나, `LIKE '%text'`와 같이 인덱스를 효율적으로 탈 수 없을 때 주로 발생합니다.

## 4. 클러스터형 vs. 비클러스터형 인덱스

### 클러스터형 인덱스 (Clustered Index)
-   **데이터 자체가 인덱스**: 테이블의 데이터 행 자체가 인덱스에 의해 물리적으로 정렬됩니다. 마치 영어 사전이 단어 순서대로 정렬되어 있는 것과 같습니다.
-   테이블당 하나만 존재할 수 있으며, 일반적으로 기본 키(Primary Key)에 의해 생성됩니다.
-   범위 검색 시 매우 뛰어난 성능을 보입니다.

### 비클러스터형 인덱스 (Non-Clustered Index)
-   **데이터 위치를 가리키는 포인터**: 인덱스는 정렬되어 있지만, 실제 데이터는 다른 곳에 저장되어 있습니다. 인덱스는 데이터의 위치(주소)를 가리키는 포인터를 가집니다. 책의 '찾아보기'와 같습니다.
-   테이블당 여러 개를 생성할 수 있습니다.

## 5. 인덱스 활용 전략

### 복합 인덱스 (Composite Index)
-   두 개 이상의 컬럼을 묶어 하나의 인덱스로 만드는 것입니다.
-   `WHERE` 절에서 여러 컬럼이 함께 자주 사용될 때 유용합니다. (예: `WHERE a = ? AND b = ?`)
-   **컬럼 순서가 매우 중요합니다.** `(a, b)` 순서로 인덱스를 생성하면, `WHERE a = ?` 또는 `WHERE a = ? AND b = ?` 조건에는 인덱스가 효과적으로 사용되지만, `WHERE b = ?` 조건에는 사용되지 못할 수 있습니다.

### 커버링 인덱스 (Covering Index)
-   쿼리에 필요한 모든 데이터가 인덱스에 포함되어 있어, **테이블에 접근할 필요 없이 인덱스만으로 결과를 반환**하는 인덱스입니다.
-   테이블 데이터에 접근하는 I/O가 발생하지 않으므로 조회 성능이 크게 향상됩니다.
-   **예시**: `user` 테이블에 `(email, name)`으로 복합 인덱스가 걸려있을 때, `SELECT email, name FROM user WHERE email = 'test@test.com'` 쿼리는 커버링 인덱스를 통해 처리될 수 있습니다.

## 6. 인덱스의 단점과 고려사항

인덱스는 조회 성능을 높이지만, 항상 좋은 것만은 아닙니다. 다음과 같은 단점을 고려하여 전략적으로 사용해야 합니다.

-   **쓰기 성능 저하**: `INSERT`, `UPDATE`, `DELETE` 작업이 발생할 때마다 인덱스 테이블도 함께 수정되어야 하므로 쓰기 성능이 저하됩니다. 특히 `UPDATE`가 빈번한 컬럼에는 인덱스를 신중하게 적용해야 합니다.
-   **추가 저장 공간 필요**: 인덱스는 데이터와 별도의 저장 공간을 차지합니다. 인덱스가 많아질수록 디스크 공간 부담이 커집니다.
-   **잘못된 인덱스 설계**: 쿼리에 사용되지 않거나, 중복이 많은(**카디널리티**가 낮은) 컬럼에 인덱스를 생성하면 오히려 성능에 악영향을 줄 수 있습니다.
> - **카디널리티(Cardinality)**: 특정 컬럼의 유니크(Unique)한 값의 개수. 카디널리티가 높을수록(예: 주민등록번호) 인덱스 효율이 좋고, 낮을수록(예: 성별) 효율이 떨어집니다.

## 7. 인덱스 유지보수 전략

인덱스는 생성하고 끝이 아니라, 지속적인 관리가 필요한 운영의 대상입니다.

-   **사용되지 않는 인덱스 탐지 및 제거**: 사용되지 않는 인덱스는 조회 성능에 아무런 이득 없이 쓰기 성능만 저하시키고 저장 공간만 낭비하므로, 주기적으로 확인하여 제거하는 것이 좋습니다. 대부분의 DBMS는 인덱스 사용 통계를 제공하는 모니터링 뷰를 지원합니다.
    -   **PostgreSQL**: `pg_stat_user_indexes` 뷰의 `idx_scan` 컬럼이 0에 가깝다면 사용되지 않을 확률이 높습니다.
    -   **MS-SQL**: `sys.dm_db_index_usage_stats` 뷰를 통해 인덱스별 조회, 업데이트 통계를 확인할 수 있습니다.

-   **인덱스 재구성 (Rebuild / Reorganize)**: 데이터의 삽입, 삭제, 수정이 빈번하게 발생하면 인덱스에 단편화(fragmentation)가 발생하여 성능이 저하될 수 있습니다. 이 경우, 주기적으로 인덱스를 재구성하여 최적의 상태를 유지해주는 작업이 필요할 수 있습니다.

-   **실행 계획(Execution Plan) 분석**: 새로운 인덱스를 추가하거나 쿼리를 변경했을 때, `EXPLAIN`과 같은 명령어로 데이터베이스의 실행 계획을 분석하여 의도한 대로 인덱스가 잘 사용되고 있는지 반드시 확인하는 습관이 중요합니다.

## 8. 결론: 올바른 인덱스 설계

결론적으로 인덱스는 **조회 빈도가 높고, `WHERE` 절이나 `JOIN` 조건에 자주 사용되며, 데이터 중복이 적은(카디널리티가 높은) 컬럼**에 우선적으로 적용하는 것이 중요합니다. 무분별한 인덱스 생성은 오히려 성능 저하의 원인이 될 수 있으므로, 쿼리 실행 계획을 분석하고 데이터의 특성을 고려하여 전략적으로 설계하고 지속적으로 관리해야 합니다.