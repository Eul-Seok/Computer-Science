# 게임 개발 성능 최적화

## 1. 게임 루프에서 Update와 Render를 분리하는 이유

게임 루프에서 Update와 Render를 분리하는 이유는 게임의 안정성과 시각적 부드러움을 동시에 확보하기 위해서입니다.

> **게임 루프 (Game Loop)**: 대부분의 게임이 따르는 핵심 실행 구조로, '입력 처리 → 로직 업데이트 → 화면 렌더링' 과정을 끊임없이 반복합니다. 이 루프가 얼마나 빨리 도는지가 게임의 프레임 속도(FPS)를 결정합니다.

먼저 Update 단계는 게임의 핵심 로직을 처리하는 부분입니다. 여기에는 물리 계산, AI 동작, 입력 처리, 상태 변화 등이 포함되며, 게임의 실제 동작을 결정합니다. 반면 Render 단계는 화면에 그래픽을 출력하는 역할로, 현재 상태를 시각적으로 표현하는 데 집중합니다.

이 두 단계를 분리하면 여러 가지 장점이 있습니다. 가장 중요한 건 로직의 안정성과 렌더링의 일관성을 각각 독립적으로 유지할 수 있다는 점입니다. 예를 들어, Update는 초당 30회로 고정하고(Fixed Timestep), Render는 하드웨어 성능에 따라 가능한 한 빠르게(Variable Timestep) 처리하면, 게임 로직은 안정적으로 실행되면서도 화면은 더 부드럽게 표현됩니다.

> **프레임 스킵 (Frame Skipping)**: 렌더링이 게임 로직 업데이트 속도를 따라가지 못할 때, 일부 프레임의 렌더링을 건너뛰어 로직과 렌더링 사이의 간격을 맞추는 기법입니다. 이를 통해 게임 속도가 느려지는 것을 방지할 수 있습니다.

또한, Update와 Render를 분리하면 멀티스레딩 구조를 적용하기 용이해집니다. 예를 들어 렌더링은 렌더 스레드에서, 게임 로직은 메인 스레드에서 처리하여 병렬로 작업을 수행함으로써 성능을 향상시킬 수 있습니다.

> **멀티스레딩 (Multithreading)**: 하나의 프로세스 내에서 여러 개의 스레드를 동시에 실행하여 작업을 병렬로 처리하는 기법입니다. CPU의 여러 코어를 효율적으로 활용하여 전체적인 성능을 높일 수 있습니다.

결국 이 구조는 게임의 반응성과 시각적 품질을 동시에 높이는 핵심 설계 방식이며, 대부분의 상용 게임 엔진에서도 기본적으로 적용되고 있습니다.

## 2. Fixed Timestep vs Variable Timestep

Fixed timestep은 일정한 시간 간격(예: 60FPS 기준 16.6ms)으로 게임 로직을 업데이트하는 방식입니다. 프레임 속도와 관계없이 일정한 간격으로 물리 연산을 수행하기 때문에 계산이 안정적이고 결과의 재현성이 높습니다.

> **재현성 (Reproducibility)**: 동일한 입력과 조건 하에서 항상 같은 결과를 만들어내는 특성을 의미합니다. 재현성이 높으면 버그를 추적하고 수정하기 용이하며, 네트워크 게임에서 여러 클라이언트 간의 상태를 동기화하는 데 필수적입니다.

반면 Variable timestep은 실제 프레임 간격에 따라 로직을 업데이트하는 방식으로, 프레임이 빠르면 자주, 느리면 덜 업데이트됩니다. 이 방식은 애니메이션이나 카메라 움직임이 부드럽게 표현되지만, 프레임 드랍이 발생하면 물리 연산이 불안정해질 수 있고, 결과가 매번 달라질 수 있습니다.

> **프레임 드랍 (Frame Drop)**: 렌더링 시간이 예상보다 길어져 다음 프레임을 제시간에 보여주지 못하고 건너뛰는 현상입니다. 사용자에게는 화면이 끊기거나 버벅이는 것처럼 느껴집니다.

> **프레임 드랍과 프레임 스킵의 관계**
> 프레임 드랍은 성능 문제로 인해 발생하는 원치 않는 '현상'인 반면, 프레임 스킵은 게임 속도를 유지하기 위해 의도적으로 사용하는 '기법'입니다. 프레임 스킵은 렌더링 부하가 꾸준히 높을 때 게임이 느려지는 것을 막아주지만, 순간적인 과부하(Spike)나 게임 로직 자체의 병목으로 인한 심각한 프레임 드랍까지는 막아주지는 못합니다.

대부분의 게임 엔진은 두 방식을 혼합한 하이브리드 방식을 사용합니다. 예를 들어, 렌더링은 Variable timestep으로 처리해 부드러운 화면을 유지하고, 물리 연산은 Fixed timestep으로 처리해 안정성을 확보합니다.

## 3. GPU와 CPU 병목은 어떻게 찾고 해결하나요?

게임 개발에서 성능 최적화를 위해 GPU와 CPU 병목을 정확히 파악하고 해결하는 것이 매우 중요합니다.

> **병목 (Bottleneck)**: 전체 시스템의 성능이나 처리량이 하나의 구성 요소에 의해 제한받는 현상을 의미합니다. 물병의 좁은 목처럼 데이터의 흐름이 한 곳에서 정체되는 것을 비유합니다.

먼저 **CPU 병목**은 주로 **Draw Call**이 과도하게 많거나, 게임 로직(AI, 물리)이 복잡할 때 발생합니다.

> **Draw Call**: CPU가 GPU에게 '이 오브젝트를 그려라'라고 보내는 렌더링 명령입니다. Draw Call이 많아지면 CPU가 GPU에게 명령을 전달하는 데 많은 시간을 소모하여 병목이 발생합니다.

이를 해결하기 위해서는 프로파일링 도구를 활용해 병목 지점을 분석하고, 필요 시 멀티스레딩을 적용해 부하를 분산시킵니다.

반면 **GPU 병목**은 쉐이더 과부하, **오버드로우(Overdraw)**, 텍스처 해상도 과다 등으로 인해 발생합니다.

> **오버드로우 (Overdraw)**: 화면의 한 픽셀이 여러 번 덧칠해지는 현상입니다. 예를 들어 반투명한 오브젝트들이 겹쳐있을 때 발생하며, 불필요한 픽셀 연산으로 GPU에 부담을 줍니다.

이를 해결하기 위해서는 다음과 같은 전략을 사용합니다:

-   **LOD (Level of Detail)**: 거리에 따라 모델의 폴리곤 수를 줄여 렌더링 부하를 낮춥니다.
-   **컬링(Culling) 기법 활용**: 화면에 보이지 않는 불필요한 오브젝트를 렌더링 과정에서 제외하여 부하를 줄입니다. 주요 컬링 기법은 다음과 같습니다.
    *   **뷰 프러스텀 컬링 (View Frustum Culling)**: 카메라의 시야각(Frustum) 밖에 있는 오브젝트는 렌더링하지 않습니다. 가장 기본적이고 필수적인 컬링 기법입니다.
    *   **오클루전 컬링 (Occlusion Culling)**: 다른 오브젝트에 완전히 가려져 보이지 않는 오브젝트는 렌더링하지 않습니다. 복잡한 씬에서 효과적입니다.
    *   **후면 컬링 (Back-face Culling)**: 카메라를 등지고 있는 폴리곤(면)은 렌더링하지 않습니다. 대부분의 3D 오브젝트에 기본적으로 적용되는 매우 효율적인 기법입니다.
    *   **거리 기반 컬링 (Distance Culling)**: 카메라에서 일정 거리 이상 떨어진 작은 오브젝트들은 렌더링하지 않도록 설정하여 부하를 조절합니다.
-   **쉐이더 최적화**: 복잡한 계산을 줄이고, 조건문이나 루프를 최소화하여 GPU 연산 효율을 높입니다.

실무에서는 Unity Profiler, Unreal Insights, RenderDoc 같은 **프로파일링 도구**를 활용해 프레임 단위로 CPU/GPU 사용량을 분석하고, 병목 지점을 시각적으로 확인한 뒤 최적화합니다.

## 4. GC가 성능에 미치는 영향과 그 대응 방법

GC, 즉 Garbage Collector는 프로그래밍 언어에서 사용하지 않는 메모리를 자동으로 회수하는 기능입니다. 메모리 누수를 방지하고 개발자의 부담을 줄여주는 장점이 있지만, 성능 측면에서는 주의가 필요합니다.

> **메모리 누수 (Memory Leak)**: 더 이상 필요하지 않은 메모리가 해제되지 않고 계속 남아있어, 시스템의 가용 메모리가 점차 줄어드는 현상입니다.

GC가 동작할 때는 일반적으로 **Stop-the-world** 현상이 발생합니다. 이는 GC가 메모리를 정리하는 동안 애플리케이션의 실행이 일시적으로 멈추는 현상으로, 특히 실시간성이 중요한 게임에서는 프레임 드랍이나 입력 지연을 유발할 수 있습니다.

이러한 성능 저하를 완화하기 위해 실무에서는 다음과 같은 대응 전략을 사용합니다:

1.  **Object Pooling**
    자주 생성되고 소멸되는 객체를 미리 만들어두고 재사용하는 방식입니다. (앞선 항목에서 설명)

2.  **할당 최소화**
    Update 루프나 렌더링 루프처럼 반복적으로 실행되는 영역에서는 불필요한 객체 생성을 피하고, 가능한 한 기존 객체를 재사용합니다. 특히 스택에 생성된 데이터(값 또는 객체)를 힙 메모리에 동적으로 할당하는 행위(일종의 **박싱(Boxing)**)는 불필요한 메모리 할당과 성능 저하를 유발하므로 주의가 필요합니다.

3.  **메모리 관리 최적화**
    GC의 동작 방식과 세부 설정을 이해하고, **세대별 GC** 전략이나 GC 알고리즘 선택 등을 통해 시스템에 맞는 최적화를 수행합니다.

> **세대별 GC (Generational GC)**: '대부분의 객체는 금방 죽는다'는 가설(Weak Generational Hypothesis)에 기반한 최적화 기법입니다. 새로 생성된 객체는 Young Generation 영역에, 오랫동안 살아남은 객체는 Old Generation 영역에 두어, 수명이 짧은 객체들을 더 빠르고 효율적으로 정리합니다.

결국 GC는 편리한 기능이지만, 성능 민감한 시스템에서는 적극적인 관리와 최적화가 필요합니다.

## 5. Object Pooling

게임에서는 총알, 파티클, 이펙트처럼 짧은 시간 동안 자주 생성되고 파괴되는 객체가 많습니다. 이러한 객체를 매번 메모리에서 새로 할당하고 해제하면 성능 저하와 GC(가비지 컬렉션) 부담이 발생할 수 있습니다. 특히 실시간성이 중요한 게임에서는 프레임 드랍으로 이어질 수 있어 치명적입니다.

> **GC (Garbage Collection)**: 시스템에서 더 이상 사용하지 않는 동적 할당된 메모리(가비지)를 찾아내어 자동으로 해제하는 메모리 관리 기법입니다. GC가 실행되는 동안에는 게임 로직이 일시적으로 멈출 수 있어 프레임 드랍의 원인이 되기도 합니다.

Object Pooling은 이러한 문제를 해결하기 위한 기법으로, 미리 객체를 일정 수량 생성해두고 필요할 때 꺼내 쓰고 다시 반환하여 재사용합니다. 이를 통해 메모리 단편화를 방지하고, 생성/삭제 비용을 줄여 퍼포먼스를 안정화할 수 있습니다.

> **메모리 단편화 (Memory Fragmentation)**: 메모리를 할당하고 해제하는 과정이 반복되면서, 총 여유 공간은 충분하지만 연속된 큰 공간이 없어 새로운 메모리 할당에 실패하는 현상입니다. Object Pooling은 미리 큰 덩어리의 메모리를 할당받아 사용하므로 단편화를 줄이는 데 도움이 됩니다.

실제로 많은 게임 엔진에서는 총알, 적 스폰, 이펙트 처리 등에 Object Pooling을 적용하여 실시간 처리 성능을 유지하고, 불필요한 GC를 최소화합니다.

> **풀링된 객체는 언제 해제되나요?**
>
> 미리 할당된 풀(Pool)의 메모리는 일반적으로 게임의 특정 상태와 생명주기를 함께합니다. 가장 흔한 방식은 특정 씬(Scene)이나 레벨(Level)이 로드될 때 풀을 생성하고, 해당 씬이 끝날 때(예: 다른 레벨로 전환, 메인 메뉴로 복귀) 풀 전체를 한 번에 해제하는 것입니다. 이를 통해 수많은 객체를 개별적으로 해제하는 비용을 없애고, 관리의 복잡성을 크게 낮출 수 있습니다. 게임 전체에서 계속 사용되는 객체의 경우, 애플리케이션이 시작될 때 생성하여 종료될 때 해제하기도 합니다.

## 6. 데이터 중심 설계: 가상 함수, 캐시, 그리고 ECS

객체지향 프로그래밍(OOP)은 코드의 유연성과 확장성을 높여주는 강력한 패러다임이지만, 대규모 데이터를 실시간으로 처리해야 하는 게임 개발에서는 성능 문제를 일으키는 경우가 많습니다. `가상 함수`의 동작 방식과 `데이터 구조`가 그 대표적인 예입니다.

> **핵심 성능 개념: 캐시와 분기 예측**
>
> 이 주제를 이해하려면 CPU의 두 가지 핵심 동작 방식을 알아야 합니다.
>
> *   **CPU 캐시 (Cache):** CPU는 메인 메모리(RAM)보다 훨씬 빠른 내부 고속 메모리('캐시')를 사용합니다. 필요한 데이터가 캐시에 있으면 <b>'캐시 히트(Cache Hit)'</b>라고 하며 즉시 작업을 처리하지만, 캐시에 없어 RAM까지 가지러 가야 하면 <b>'캐시 미스(Cache Miss)'</b>라고 하며, 이는 심각한 성능 저하의 원인이 됩니다.
>
> *   **분기 예측 (Branch Prediction):** 현대 CPU는 `if`문 같은 분기문을 만났을 때, 어느 쪽으로 실행될지 '예측'하고 미리 작업을 처리하는 파이프라인 방식을 씁니다. 예측이 맞으면 매우 빠르지만, 틀릴 경우(**'분기 예측 실패'**) 하던 작업을 모두 버리고 다시 시작해야 해서 큰 성능 손실이 발생합니다. 가상 함수 호출처럼 목적지를 예측하기 어려운 코드는 분기 예측 실패를 유발하기 쉽습니다.

### 문제점 1: 가상 함수(Virtual Function)의 비용

C++과 같은 언어에서 가상 함수는 다형성을 구현하는 핵심 메커니즘입니다. 하지만 가상 함수 호출은 여러 단계를 거치는 간접 호출이라, CPU 입장에서 예측이 어렵고 메모리를 여러 번 참조해야 합니다. 이 과정에서 <b>캐시 미스(Cache Miss)</b>와 **분기 예측 실패**가 발생할 확률이 높아져 성능 저하의 직접적인 원인이 됩니다.

### 문제점 2: 객체 중심 데이터 구조의 비효율성

더 근본적인 문제는 데이터의 저장 방식에 있습니다. 전통적인 OOP에서는 관련된 데이터와 함수를 하나의 `객체`로 묶어 관리하는 **Array of Objects (AoO)** 구조를 주로 사용합니다. 예를 들어, `GameObject` 객체들의 배열을 순회한다고 상상해봅시다. 각 객체는 메모리 여러 곳에 흩어져 있기 때문에, CPU는 필요한 데이터(예: `position`)를 찾기 위해 계속해서 메모리를 점프해야 합니다. 이는 캐시 효율을 크게 떨어뜨립니다.

> **Array of Objects (AoO) vs Structure of Arrays (SoA)**
> *   **AoO (객체 배열)**: `[객체1(pos, vel)], [객체2(pos, vel)], [객체3(pos, vel)]` 처럼 객체 단위로 데이터를 묶습니다. 메모리가 흩어지기 쉽습니다.
> *   **SoA (구조체 배열)**: `[pos1, pos2, pos3]`, `[vel1, vel2, vel3]` 처럼 데이터 종류별로 묶습니다. 메모리가 연속적이므로 캐시에 매우 친화적입니다.

### 해결책: 데이터 중심 설계(Data-Oriented Design, DOD)

이러한 한계를 극복하기 위해 현대 게임 엔진에서는 '객체'가 아닌 '데이터'의 처리 방식에 집중하는 <b>데이터 중심 설계(DOD)</b>를 채택합니다. DOD의 핵심은 데이터를 **SoA** 구조로 구성하여 CPU가 효율적으로 작업할 수 있는 환경을 만드는 것입니다.

<b>ECS(Entity Component System)</b>는 바로 이 데이터 중심 설계를 구현하는 대표적인 아키텍처 패턴입니다.

> **ECS (Entity Component System)의 구성**
> *   **Entity**: 단순히 객체를 구분하는 ID(숫자)입니다.
> *   **Component**: `Position`, `Velocity` 등 순수한 데이터 덩어리입니다.
> *   **System**: 특정 컴포넌트들을 가진 엔티티들을 찾아 처리하는 로직(함수)입니다.

ECS는 데이터(Component)와 로직(System)을 완전히 분리하고, 같은 종류의 컴포넌트들을 메모리에 연속으로 모아(SoA) 캐시 효율을 극대화합니다.

### 가상 함수의 대체

ECS 구조에서는 가상 함수 없이도, 데이터의 구성 자체를 통해 다형성(다양한 행동)을 구현합니다.

1.  **시스템 선택을 위한 컴포넌트 조합 (Composition as System Selector):** 가장 기본적이고 순수한 ECS 방식입니다. 엔티티의 행동은 <b>어떤 시스템이 자신을 처리할지를 결정하는 데이터 '태그'</b>의 조합으로 정의됩니다. 예를 들어, `PlayerInput` 컴포넌트를 가진 엔티티는 `PlayerSystem`의 처리 대상이 되고, `AIController` 컴포넌트를 가진 엔티티는 `AISystem`의 처리 대상이 되는 식입니다. 객체에 행동이 내장된 것이 아니라, 데이터 조합에 따라 각기 다른 로직(시스템)이 적용됩니다.

2.  **데이터로서의 함수 (Function as Data):** 보다 동적인 행동이 필요할 때 사용하는 고급 기법으로, 컴포넌트가 **로직을 가리키는 함수 포인터를 데이터의 일종으로** 포함하게 하는 방식입니다. 이는 '순수한 데이터' 원칙에서 살짝 벗어나지만, 가상 함수 테이블을 사용하는 것보다 훨씬 명시적이고 제어하기 쉽습니다. 예를 들어, 각기 다른 스킬 효과를 가진 `SkillComponent`가 각자의 로직 함수를 포인터로 들고 있게 할 수 있습니다.

결론적으로, 데이터 중심 설계는 가상 함수라는 보이지 않는 메커니즘 대신, 눈에 보이는 **데이터의 조합과 값**을 통해 행동을 결정함으로써 CPU 처리 성능을 극대화하는 설계 방식입니다.

### 가독성과의 트레이드오프

다만, 데이터 중심 설계(ECS)는 성능에서 큰 이점을 얻는 대신, 전통적인 객체지향에 익숙한 개발자에게는 **가독성과 코드 추적의 어려움**이라는 단점을 가질 수 있습니다. 하나의 논리적인 기능(예: 플레이어의 공격)이 여러 시스템과 컴포넌트에 걸쳐 분산되기 때문입니다.

하지만 이는 다른 관점의 가독성을 제공하기도 합니다. 예를 들어, 게임의 모든 물리 로직은 오직 `PhysicsSystem`에만 존재하므로, 기능 단위로 코드를 이해하고 수정하기에는 더 용이할 수 있습니다. 결국 이는 '인간 친화적인 직관성'과 '컴퓨터 친화적인 성능' 사이의 트레이드오프이며, 성능이 중요한 게임 개발에서는 이 단점을 감수하고 ECS를 채택하는 경우가 많습니다.

## 7. 게임에서 해시 테이블이 사용되는 예시

<b>해시 테이블(Hash Table)</b>은 평균적으로 O(1)의 매우 빠른 시간 복잡도로 데이터를 삽입, 삭제, 조회할 수 있는 자료구조로, 게임 개발의 여러 영역에서 핵심적으로 사용됩니다.

> **해시 테이블 (Hash Table)**: 키(Key)를 해시 함수(Hash Function)에 입력하여 얻은 값(해시)을 배열의 인덱스로 사용하여 값(Value)을 저장하고 조회하는 자료구조입니다. 충돌이 없을 경우, 키만 알면 즉시 데이터에 접근할 수 있습니다.

-   **리소스 관리**: "player_character.fbx" 같은 파일 경로(문자열 키)를 사용해 해당 리소스 객체를 빠르게 찾는 데 사용됩니다.
-   **오브젝트/엔티티 관리**: 게임 내 수많은 오브젝트를 고유 ID(정수 키)로 관리하고, ID를 통해 오브젝트의 데이터를 즉시 조회하는 데 사용됩니다.
-   **네트워크 패킷 처리**: 패킷의 종류를 나타내는 ID(키)에 따라 어떤 처리 함수(핸들러)를 호출할지 결정하는 데 사용됩니다.
-   **애니메이션 상태 관리**: "Run", "Jump" 같은 상태 이름(문자열 키)에 따라 해당 애니메이션 클립이나 상태 머신 로직을 연결하는 데 사용됩니다.

이처럼 해시 테이블은 빠른 키 기반 조회가 필요한 모든 곳에서 성능과 코드의 효율성을 높이는 데 기여합니다.