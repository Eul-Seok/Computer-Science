# 해시 테이블의 원리와 충돌 해결 방법

## 1. 해시 테이블 (Hash Table)의 기본 원리
해시 테이블은 **키(Key)를 값(Value)에 매핑**하여 데이터를 빠르게 저장하고 검색하는 자료구조입니다.

- **동작 방식**:
    1.  키를 <b>해시 함수(Hash Function)</b>에 입력하여 고유한 숫자 값인 <b>해시(Hash)</b>를 생성합니다.
    2.  이 해시 값을 배열의 <b>인덱스(Index)</b>로 사용하여 값을 저장하거나 조회합니다.
- **장점**:
    - 키를 통해 값을 바로 찾을 수 있으므로, 평균적으로 <b>O(1)</b>의 매우 빠른 시간 복잡도를 가집니다.

---

## 2. 충돌 (Collision) 문제
서로 다른 키가 해시 함수를 거쳤을 때 **같은 해시 값(인덱스)을 반환**하는 현상을 <b>충돌(Collision)</b>이라고 합니다. 충돌이 발생하면 여러 데이터가 같은 공간에 저장되어야 하므로, 이를 해결하기 위한 전략이 반드시 필요합니다.

---

## 3. 충돌 해결 방법

### 1) 체이닝 (Chaining)
- **원리**: 충돌이 발생한 인덱스에 데이터를 **연결 리스트(Linked List)** 형태로 계속 이어 붙여 저장합니다.
- **장점**:
    - 구현이 비교적 간단하고, 데이터가 많아져도 유연하게 확장이 가능합니다.
- **단점**:
    - 특정 인덱스에 데이터가 집중되면 연결 리스트가 길어져, 탐색 성능이 저하될 수 있습니다. (최악의 경우 O(n))

### 2) 개방 주소법 (Open Addressing)
- **원리**: 충돌이 발생했을 때, 다른 <b>빈 공간(버킷)</b>을 찾아 데이터를 저장합니다.
- **탐색 방식**:
    - **선형 탐색 (Linear Probing)**: 현재 인덱스에서부터 순차적으로 다음 빈 공간을 찾습니다.
    - **제곱 탐색 (Quadratic Probing)**: 탐색 간격을 제곱수로 늘려가며 빈 공간을 찾습니다.
    - **이중 해싱 (Double Hashing)**: 두 개의 해시 함수를 조합하여 탐색 간격을 결정합니다.
- **장점**:
    - 추가적인 자료구조(연결 리스트)를 사용하지 않아 메모리 사용이 효율적입니다.
- **단점**:
    - 데이터가 특정 영역에 몰리는 **클러스터링(Clustering)** 현상이 발생할 수 있습니다.
    - 데이터 삭제 처리가 복잡합니다.

---

## 4. 결론

| 구분 | 체이닝 (Chaining) | 개방 주소법 (Open Addressing) |
| :--- | :--- | :--- |
| **저장 방식** | 연결 리스트에 추가 | 다른 빈 공간 탐색 |
| **메모리 효율** | 추가 공간 필요 | 상대적으로 효율적 |
| **성능** | 데이터 집중 시 저하 | 클러스터링 발생 시 저하 |

해시 테이블은 빠른 접근 속도를 제공하는 강력한 자료구조지만, **해시 함수의 품질**과 **충돌 해결 전략**에 따라 전체 성능이 크게 좌우됩니다. 따라서 데이터의 특성과 요구사항에 맞는 적절한 방식을 선택하는 것이 매우 중요합니다.

---

## 5. 참고: 언리얼 엔진(Unreal Engine)의 경우
언리얼 엔진의 해시 컨테이너(`TMap`, `TSet`)는 성능 최적화를 위해 전통적인 체이닝이나 개방 주소법을 그대로 사용하지 않고, **두 방식을 혼합한 독자적인 방법**을 사용합니다.

- **핵심 원리**: 충돌이 발생한 요소들을 **연속된 메모리 공간에 함께 저장**하면서, 각 요소를 포인터로 연결합니다.
- **장점**:
    - **캐시 효율성**: 데이터들이 메모리상에 모여 있어 개방 주소법처럼 캐시 친화적입니다.
    - **클러스터링 완화**: 전통적인 선형 탐색 같은 방식이 아니므로 클러스터링 문제를 피할 수 있습니다.

결과적으로, 순수 체이닝의 단점인 포인터 탐색 비용(캐시 미스)과 순수 개방 주소법의 단점인 클러스터링 문제를 모두 개선하려는 하이브리드 전략입니다.
