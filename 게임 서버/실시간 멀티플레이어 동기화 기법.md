# 15. 실시간 멀티플레이어 동기화 기법

실시간 멀티플레이어 게임에서 네트워크 지연(Latency)은 피할 수 없는 숙제입니다. 사용자의 입력이 서버에 도달하고, 그 결과가 다시 클라이언트에게 돌아오기까지의 시간 차이는 플레이어의 경험을 크게 저해합니다. 이 문제를 해결하고, 지연 속에서도 쾌적하고 공정한 게임 플레이를 제공하기 위해 사용되는 핵심 기술이 바로 **클라이언트 측 예측**, **서버 재조정**, **지연 보상**입니다.

## 1. 클라이언트 측 예측 (Client-side Prediction)

**클라이언트 측 예측**은 네트워크 지연을 숨기기 위해, 서버의 응답을 기다리지 않고 클라이언트가 먼저 사용자 입력을 처리하여 화면에 반영하는 기술입니다.

> **실무 예시**: FPS 게임에서 플레이어가 'W' 키를 누르면, 클라이언트는 서버의 허락을 기다리지 않고 즉시 캐릭터를 앞으로 움직입니다. 만약 서버의 응답을 기다린다면, 플레이어는 키를 누르고 0.1초(100ms 지연 기준) 뒤에야 캐릭터가 움직이는 것을 보게 되어 조작감이 매우 나쁘다고 느낄 것입니다.

### 동작 원리
1.  **즉시 반응**: 사용자가 입력을 하면(예: 이동, 점프), 클라이언트는 즉시 해당 입력에 따른 결과를 시뮬레이션하여 화면에 보여줍니다.
> - **시뮬레이션(Simulation)**: 실제와 유사한 상황을 만들어 시험하는 것. 여기서는 서버가 계산할 게임 물리 법칙이나 규칙을 클라이언트가 미리 흉내 내어 실행하는 것을 의미합니다.
2.  **입력 전송**: 동시에 해당 입력과 입력이 발생한 시간을 서버로 전송합니다.
3.  **서버 결과 수신**: 잠시 후, 서버로부터 해당 입력이 처리된 실제 결과(권위 있는 상태)를 받습니다.
> - **권위 있는 상태(Authoritative State)**: 게임의 최종적인 '진실'로 간주되는 서버의 데이터. 클라이언트의 예측과 서버의 판단이 다를 경우, 모든 클라이언트는 이 상태를 따라야 합니다.
4.  **오차 보정**: 클라이언트가 예측한 결과와 서버가 보내준 실제 결과를 비교하여, 오차가 있다면 서버의 데이터에 맞춰 보정합니다. (이 과정이 '서버 재조정'입니다.)

### 장점과 단점
-   **장점**: 네트워크 지연을 사용자가 거의 느끼지 못하게 하여 즉각적인 반응성을 제공합니다. 특히 FPS, 액션, 레이싱 게임처럼 빠른 조작이 중요한 장르에서 플레이어 경험을 획기적으로 향상시킵니다.
-   **단점**: 예측이 빗나갈 경우, 클라이언트의 캐릭터가 갑자기 다른 위치로 순간이동하는 것처럼 보이는 **보정 티(Teleport Glitch)**가 발생할 수 있습니다.
> - **보정 티(Teleport Glitch)**: 클라이언트의 예측 위치와 서버가 보내준 실제 위치의 차이가 커서, 이를 바로잡는 과정에서 캐릭터가 순간이동하는 것처럼 보이는 현상. 플레이어에게 시각적인 불편함을 줍니다.

## 2. 서버 재조정 (Server Reconciliation)

**서버 재조정**은 클라이언트 측 예측의 필연적인 부작용인 '예측 오류'를 바로잡는 과정입니다. 항상 서버의 상태를 최종적인 '진실'로 간주하고, 클라이언트의 상태를 서버에 맞춰 동기화하는 것을 의미합니다.

### 필요한 이유: 서버 권위 모델 (Server Authority)
멀티플레이어 게임에서 모든 중요한 판정(이동, 충돌, 명중 등)은 서버가 최종 권한을 가집니다. 이를 **서버 권위 모델**이라고 하며, 치팅을 방지하고 모든 클라이언트에게 일관된 게임 상태를 보장하기 위해 필수적입니다.
> - **치팅(Cheating)**: 게임의 규칙을 어기고 부정한 방법을 사용하여 이득을 취하는 행위. 예를 들어, 클라이언트에서 자신의 위치를 마음대로 조작하는 것을 막기 위해 서버가 최종 위치를 판정합니다.
- 클라이언트 측 예측은 이 모델을 유지하면서 반응성을 높이기 위한 트릭이며, 따라서 예측이 틀렸을 경우 반드시 서버의 권위 있는 상태를 따라야 합니다.

### 동작 과정
1.  클라이언트는 자신이 보냈던 입력들의 목록(시간순)을 잠시 보관합니다.
2.  서버로부터 과거 특정 시간(T)의 상태(위치, 속도 등)를 받습니다.
3.  클라이언트는 자신의 현재 상태를 서버가 보내준 시간(T)의 상태로 되돌립니다.
4.  그 후, 보관하고 있던 입력 목록에서 시간 T 이후에 발생한 입력들을 순서대로 다시 실행(re-apply)합니다.
> - **다시 실행(Re-apply)**: 서버로부터 받은 과거 상태를 기준으로, 그 이후에 사용자가 입력했던 값들을 다시 적용하여 현재 상태를 재계산하는 과정.
5.  이 과정을 통해 클라이언트의 예측 오류는 수정되고, 현재 상태는 서버의 판정과 일치하게 됩니다.

### 예측 오차 보정 전략 및 선택 기준
예측 오차를 어떻게 처리할지는 단순히 오차의 크기뿐만 아니라, 게임의 특성을 종합적으로 고려하여 결정해야 합니다.

#### 보정 방법의 종류
| 오차 크기 | 전략 | 특징 | 주요 사용처 |
| :--- | :--- | :--- | :--- |
| **큼** | **즉시 보정 (Snap)** | 가장 정확하지만, 캐릭터가 순간이동하는 것처럼 보여 시각적으로 거슬림. | 위치 정확도가 매우 중요한 경쟁 게임, 디버깅 모드. |
| **큼** | **점진적 보정 (Gradual)** | 일정 시간 동안 부드럽게 목표 위치로 이동시켜 시각적 충격을 완화함. | 대부분의 3인칭 액션 게임, RPG 등에서 사용. |
| **작음** | **부드러운 보간 (Interpolation)** | 거의 티 나지 않게 오차를 수정하여 부드러운 움직임을 유지함. | 일반적인 캐릭터 이동 보정 시 기본적으로 사용. |
| **아주 작음** | **무시 (Ignore)** | 오차가 특정 임계값 이하라면 무시하여 불필요한 보정 비용을 줄임. | 오차가 게임 플레이에 거의 영향을 주지 않는 경우. |
> - **임계값(Threshold)**: 어떤 값의 경계. 여기서는 '이 정도 오차까지는 괜찮다'고 판단하는 기준값을 의미합니다.

#### 전략 선택 가이드
-   **게임 장르**:
    -   **경쟁적인 FPS/대전 액션**: 정확성이 최우선입니다. 상대방의 위치가 0.1초라도 정확해야 하므로, 시각적인 부드러움보다 **즉시 보정(Snap)**을 선호하는 경우가 많습니다.
    -   **MMORPG/3인칭 액션**: 몰입감과 시각적 경험이 중요합니다. 캐릭터가 순간이동하면 어색하므로, 오차가 크더라도 **점진적 보정(Gradual Correction)**을 통해 부드럽게 따라잡도록 만듭니다.

-   **게임 시점**:
    -   **1인칭 시점**: 자신의 캐릭터가 보이지 않으므로, 자기 자신에 대한 위치 보정은 시각적으로 덜 민감합니다.
    -   **3인칭 시점**: 자신의 캐릭터가 화면 중앙에 계속 보이므로, 작은 순간이동도 크게 느껴집니다. 따라서 **점진적 보정**이나 **부드러운 보간**이 거의 필수적입니다.

-   **네트워크 환경**:
    -   **안정적인 저지연 환경**: 예측 오차가 적고 작게 발생하므로, 부드러운 보간만으로도 충분할 수 있습니다.
    -   **불안정한 고지연 환경 (모바일 등)**: 예측 오차가 크고 빈번하게 발생합니다. 작은 오차는 보간으로 처리하고, 큰 오차는 점진적 보정으로 처리하는 등 **상황에 따라 여러 전략을 혼합**하는 견고한 시스템이 필요합니다.

## 3. 지연 보상 (Lag Compensation)

**지연 보상**은 "내 화면에서는 맞았는데, 왜 안 맞았다고 나오지?"와 같은 네트워크 지연으로 인한 불공정한 판정을 보완하기 위한 기술입니다. 서버가 플레이어의 입력을 처리할 때, 해당 플레이어의 지연 시간을 감안하여 **과거의 특정 시점**을 기준으로 판정을 내리는 방식입니다.

### 대표적인 사례: FPS 총격 판정
1.  **플레이어 A의 시점**: 플레이어 A는 자신의 화면에 보이는 플레이어 B의 위치에 조준하고 총을 쏩니다. 이 정보(총격 시간 T)가 서버로 전송됩니다.
2.  **서버의 처리**: 총격 정보가 서버에 도달했을 때(T + A의 지연 시간), 플레이어 B는 이미 다른 곳으로 이동했을 수 있습니다.
3.  **시간 되돌리기**: 이때 서버는 A의 지연 시간을 계산하여, "A가 총을 쐈던 시간 T에 B는 어디에 있었는가?"를 판단합니다. 이를 위해 서버는 모든 플레이어의 과거 위치 기록을 잠시 **히스토리 버퍼**에 저장해 둡니다.
> - **히스토리 버퍼(History Buffer)**: 판정을 위해 필요한 오브젝트들의 과거 상태(위치, 상태 등)를 일정 시간 동안 저장해두는 메모리 공간.
4.  **과거 기준 판정**: 서버는 B의 위치를 시간 T 기준으로 되돌린 후, 그 위치에 A의 총알이 맞았는지를 판정합니다.

### 장점과 단점
-   **장점**: 플레이어가 보는 화면을 기준으로 판정이 이루어지므로 매우 직관적이고 공정한 경험을 제공합니다. ('What You See Is What You Shoot')
-   **단점**:
    -   서버가 모든 플레이어의 과거 위치 기록을 저장해야 하므로 메모리 부담이 있습니다.
    -   지연이 매우 높은 플레이어로 인해, 이미 엄폐물 뒤로 숨은 플레이어가 맞는 것처럼 보이는 불쾌한 경험(죽고 나서 총알이 날아오는 느낌)이 발생할 수 있습니다.

## 4. 주요 게임 엔진 및 기술 사례

이러한 동기화 기술들은 실제 게임 엔진에서 프레임워크나 플러그인 형태로 제공되기도 합니다.
> - **프레임워크/플러그인**: 특정 기능을 쉽게 구현할 수 있도록 미리 만들어진 코드의 집합 또는 확장 기능.

-   **Unreal Engine**:
    -   `CharacterMovementComponent`에 클라이언트 측 예측과 서버 재조정 기능이 매우 정교하게 기본 내장되어 있어, 개발자가 별도 구현 없이도 캐릭터의 부드러운 이동 동기화를 구현할 수 있습니다.
    -   최신 버전에서는 이를 일반화한 `Network Prediction` 플러그인을 제공하여, 캐릭터뿐만 아니라 차량, 물리 객체 등 다양한 액터에 예측 및 재조정 로직을 적용할 수 있도록 지원합니다.
    > - **액터(Actor)**: 언리얼 엔진에서 레벨에 배치할 수 있는 모든 오브젝트를 의미하는 기본 단위.

-   **Unity**:
    -   공식적으로 지원하는 `Netcode for GameObjects`에서 기본적인 클라이언트 측 예측을 지원하지만, 언리얼 엔진만큼 정교한 기능이 내장되어 있지는 않습니다.
    -   물리 기반 객체나 복잡한 예측/재조정 로직은 개발자가 직접 구현하거나, `Photon Quantum`과 같은 전문적인 상용 솔루션을 사용하는 경우가 많습니다.
    > - **물리 기반 객체(Physics-based Object)**: 게임 엔진의 물리 법칙(중력, 마찰, 충돌 등)에 따라 움직이는 오브젝트. 예측이 매우 까다롭습니다.

-   **Source Engine (Valve)**:
    -   `Counter-Strike`, `Team Fortress 2` 등에 사용된 엔진으로, 정교한 지연 보상(Lag Compensation) 구조로 유명합니다.
    -   앞서 설명한 '시간 되돌리기' 기법을 통해 서버가 모든 플레이어의 지연을 고려하여 총격 판정을 내리므로, 쾌적하고 반응성 좋은 슈팅 경험을 제공하는 데 큰 기여를 했습니다.

## 5. 결론

클라이언트 측 예측과 서버 재조정은 **반응성**을, 지연 보상은 **공정성**을 확보하기 위한 핵심 기술입니다. 이 세 가지 기법은 서로 맞물려 동작하며, 현대 멀티플레이어 게임의 쾌적한 플레이 경험을 만드는 근간을 이룹니다.